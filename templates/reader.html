<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>

    <!-- Reader Mode Detection Meta Tags -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="{{ book.metadata.title }}">
    {% if book.metadata.creator %}
    <meta name="author" content="{{ book.metadata.creator }}">
    <meta property="article:author" content="{{ book.metadata.creator }}">
    {% endif %}
    <meta name="description" content="Reading {{ book.metadata.title }}">

    <!-- Schema.org markup for Reader Mode -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "{{ book.metadata.title }}",
      {% if book.metadata.creator %}"author": {
        "@type": "Person",
        "name": "{{ book.metadata.creator }}"
      },{% endif %}
      "inLanguage": "en"
    }
    </script>
    <style>
        /* Theme Variables */
        :root {
            --bg-main: #ffffff;
            --bg-sidebar: #f8f9fa;
            --bg-button: #f8f9fa;
            --bg-button-hover: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --border-light: #e9ecef;
            --border-medium: #dee2e6;
            --border-dark: #adb5bd;
            --accent-primary: #3498db;
            --accent-success: #28a745;
            --accent-active: #d63384;
            --heading-color: #333333;
        }

        body.dark-mode {
            --bg-main: #1a1a1a;
            --bg-sidebar: #2d2d2d;
            --bg-button: #3d3d3d;
            --bg-button-hover: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --border-light: #3d3d3d;
            --border-medium: #4a4a4a;
            --border-dark: #5a5a5a;
            --accent-primary: #7db8f5;
            --accent-success: #98c379;
            --accent-active: #e06c75;
            --heading-color: #d4d4d4;
        }

        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: var(--bg-main); transition: background-color 0.3s, color 0.3s; }

        /* Sidebar */
        #sidebar { width: 300px; background: var(--bg-sidebar); border-right: 1px solid var(--border-light); overflow-y: auto; padding: 60px 20px 20px 20px; flex-shrink: 0; transition: transform 0.3s ease, width 0.3s ease, padding 0.3s ease, background-color 0.3s, border-color 0.3s; position: relative; z-index: 10; }

        /* Sidebar Collapsed State */
        body.sidebar-collapsed #sidebar { transform: translateX(-100%); width: 0; padding: 0; border-right: none; overflow: hidden; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: var(--text-secondary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-medium); transition: color 0.3s, border-color 0.3s; }
        .nav-home { display: block; margin-bottom: 20px; color: var(--accent-primary); text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; transition: color 0.3s; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: var(--text-secondary); font-size: 0.95em; display: block; padding: 4px 8px; margin: 0 -8px; line-height: 1.4; transition: all 0.2s; border-radius: 4px; }
        a.toc-link:hover { color: var(--text-primary); background: var(--bg-button-hover); }
        /* Parent chapter - light highlight */
        a.toc-link.active-parent {
            background: rgba(220, 38, 38, 0.08);
            color: var(--text-primary);
        }
        body.dark-mode a.toc-link.active-parent {
            background: rgba(248, 113, 113, 0.1);
        }
        /* Active sub-chapter - bold red */
        a.toc-link.active {
            color: #dc2626;
            font-weight: bold;
        }
        body.dark-mode a.toc-link.active {
            color: #f87171;
        }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; background: var(--bg-main); transition: background-color 0.3s; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: var(--text-primary); position: relative; transition: max-width 0.3s ease, color 0.3s; }

        /* Expand content when sidebar is collapsed */
        body.sidebar-collapsed .content-container { max-width: 900px; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: var(--heading-color); transition: color 0.3s; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; color: var(--text-primary); transition: color 0.3s; }

        /* Top Action Buttons - aligned in a row */
        .top-actions { position: absolute; top: 20px; right: 20px; display: flex; gap: 8px; align-items: center; z-index: 15; }
        .top-btn { background: var(--bg-button); color: var(--text-secondary); border: 1px solid var(--border-medium); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; text-decoration: none; display: inline-flex; align-items: center; }
        .top-btn:hover { background: var(--bg-button-hover); border-color: var(--border-dark); }
        .top-btn.copied { background: var(--accent-success); color: white; border-color: var(--accent-success); }

        /* Sidebar Toggle */
        .sidebar-toggle { position: fixed; top: 20px; left: 20px; background: var(--bg-button); color: var(--text-secondary); border: 1px solid var(--border-medium); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; z-index: 20; }
        .sidebar-toggle:hover { background: var(--bg-button-hover); border-color: var(--border-dark); }
        body.sidebar-collapsed .sidebar-toggle { left: 20px; }

        /* Responsive: Auto-collapse sidebar on mobile */
        @media (max-width: 768px) {
            /* On mobile, sidebar becomes an overlay */
            #sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 300px;
                z-index: 30;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }

            /* Show sidebar when open */
            body.sidebar-open #sidebar {
                transform: translateX(0);
            }

            /* Main content takes full width on mobile */
            #main {
                width: 100%;
            }

            /* Adjust content padding on mobile */
            .content-container {
                max-width: 100%;
                padding: 60px 20px;
            }

            /* Sidebar toggle button position on mobile */
            .sidebar-toggle {
                left: 10px;
                top: 10px;
                opacity: 1;
                transition: opacity 0.3s ease;
            }

            /* Auto-hide sidebar toggle on mobile */
            .sidebar-toggle.hidden {
                opacity: 0;
                pointer-events: none;
            }

            body.sidebar-collapsed .sidebar-toggle {
                left: 10px;
                right: auto;
            }

            /* Close button inside sidebar on mobile */
            .sidebar-close {
                display: block;
                position: absolute;
                top: 15px;
                right: 15px;
                background: var(--bg-button);
                border: 1px solid var(--border-medium);
                border-radius: 6px;
                padding: 8px 12px;
                cursor: pointer;
                font-size: 1.2em;
                color: var(--text-secondary);
                z-index: 35;
            }
            .sidebar-close:hover {
                background: var(--bg-button-hover);
            }
        }

        /* Hide close button on desktop */
        .sidebar-close {
            display: none;
        }

        /* Sidebar backdrop - separate element for click handling */
        .sidebar-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 25;
        }
        body.sidebar-open .sidebar-backdrop {
            display: block;
        }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid var(--border-light); font-family: -apple-system, sans-serif; transition: border-color 0.3s; }
        .nav-btn { text-decoration: none; color: var(--accent-primary); font-weight: bold; padding: 10px 20px; border: 1px solid var(--accent-primary); border-radius: 4px; transition: all 0.3s; }
        .nav-btn:hover { background: var(--accent-primary); color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: var(--border-dark); color: var(--text-muted); }

        /* Highlights */
        mark.highlight {
            background-color: #ffeb3b;
            cursor: pointer;
            padding: 2px 0;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        mark.highlight:hover {
            background-color: #ffd700;
        }
        body.dark-mode mark.highlight {
            background-color: #b8860b;
            color: var(--text-primary);
        }
        body.dark-mode mark.highlight:hover {
            background-color: #daa520;
        }
        /* Note indicator for highlights with notes */
        mark.highlight.has-note {
            position: relative;
        }
        mark.highlight.has-note::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -6px;
            width: 10px;
            height: 12px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%233498db'%3E%3Cpath d='M2 2v13.5a.5.5 0 0 0 .74.439L8 13.069l5.26 2.87A.5.5 0 0 0 14 15.5V2a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        /* Undo Toast for Instant Highlight */
        .highlight-undo-toast {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            font-family: -apple-system, sans-serif;
            font-size: 0.85em;
            color: var(--text-primary);
            align-items: center;
            gap: 12px;
            animation: toast-fade-in 0.2s ease-out;
        }
        .highlight-undo-toast.show {
            display: flex;
        }
        .highlight-undo-toast span {
            color: var(--text-secondary);
        }
        .highlight-undo-toast button {
            background: transparent;
            color: var(--accent-primary);
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }
        .highlight-undo-toast button:hover {
            background: var(--bg-button-hover);
        }
        @keyframes toast-fade-in {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .highlight-undo-toast.fade-out {
            animation: toast-fade-out 0.2s ease-in forwards;
        }
        @keyframes toast-fade-out {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(8px);
            }
        }

        /* Highlight Popup Menu */
        .highlight-popup {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 4px;
            z-index: 1000;
            display: none;
            font-family: -apple-system, sans-serif;
        }
        .highlight-popup.show {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .highlight-popup button {
            background: transparent;
            color: var(--text-primary);
            border: none;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9em;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        .highlight-popup button:hover {
            background: var(--bg-button-hover);
        }
        .highlight-popup .divider {
            height: 1px;
            background: var(--border-light);
            margin: 4px 0;
        }

        /* Note Tooltip on Hover */
        .highlight-note-tooltip {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            padding: 8px 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 999;
            max-width: 300px;
            font-family: -apple-system, sans-serif;
            font-size: 0.85em;
            color: var(--text-primary);
            pointer-events: none;
            display: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .highlight-note-tooltip.show {
            display: block;
        }

        /* Note Editor in Popup */
        .note-editor {
            padding: 8px;
            display: none;
        }
        .note-editor.show {
            display: block;
        }
        .note-editor textarea {
            width: 250px;
            min-height: 60px;
            padding: 8px;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
            background: var(--bg-main);
            color: var(--text-primary);
            resize: vertical;
        }
        .note-editor button {
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .note-editor button:hover {
            background: var(--accent-success);
        }

        /* Font Settings */
        .font-settings-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 20px;
        }
        .font-settings-btn {
            background: var(--bg-button);
            color: var(--text-secondary);
            border: 1px solid var(--border-medium);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-family: -apple-system, sans-serif;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .font-settings-btn:hover {
            background: var(--bg-button-hover);
            border-color: var(--border-dark);
        }
        .font-settings-panel {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            min-width: 220px;
            font-family: -apple-system, sans-serif;
        }
        .font-settings-panel.show {
            display: block;
        }
        .font-size-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .font-size-control label {
            font-size: 0.85em;
            color: var(--text-muted);
        }
        .font-size-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .font-size-btn {
            background: var(--bg-main);
            color: var(--text-primary);
            border: 1px solid var(--border-medium);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .font-size-btn:hover {
            background: var(--bg-button-hover);
            border-color: var(--border-dark);
        }
        .font-size-value {
            min-width: 40px;
            text-align: center;
            font-size: 0.9em;
            color: var(--text-primary);
        }
        .font-family-control label {
            display: block;
            font-size: 0.85em;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        .font-family-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .font-family-option {
            background: var(--bg-main);
            border: 1px solid var(--border-medium);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            color: var(--text-primary);
        }
        .font-family-option:hover {
            background: var(--bg-button-hover);
            border-color: var(--border-dark);
        }
        .font-family-option.active {
            border-color: var(--accent-primary);
            background: var(--bg-button-hover);
        }
        .font-family-option.font-serif {
            font-family: Georgia, 'Times New Roman', serif;
        }
        .font-family-option.font-sans {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .font-family-option.font-mono {
            font-family: 'SF Mono', Menlo, Consolas, monospace;
        }

    </style>
    <link rel="stylesheet" href="{{ root_path }}/static/tts/tts-player.css">
</head>
<body>
    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="Toggle sidebar">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" id="sidebarIcon">
            <!-- Hamburger icon (default - sidebar open) -->
            <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
        </svg>
    </button>

    <!-- Sidebar Backdrop (for mobile click-to-close) -->
    <div class="sidebar-backdrop" id="sidebarBackdrop" onclick="closeSidebar()"></div>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <!-- Close button for mobile -->
        <button class="sidebar-close" onclick="closeSidebar()" title="Close sidebar">‚úï</button>
        <a href="{{ root_path }}/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <main id="main">
        <div class="content-container">
            <!-- Top Action Buttons -->
            <div class="top-actions">
                <button class="top-btn" id="ttsBtn" onclick="toggleTts()" title="Read aloud">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/>
                        <path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89l.706.706z"/>
                        <path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/>
                    </svg>
                </button>
                <button class="top-btn" id="copyBtn" onclick="copyChapter()" title="Copy to clipboard for LLM">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Z"></path>
                        <path d="M2 6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-1h-1v1a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h1V6H2Z"></path>
                    </svg>
                </button>
                <a href="{{ root_path }}/highlights" class="top-btn" title="View all highlights">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M2 2v13.5a.5.5 0 0 0 .74.439L8 13.069l5.26 2.87A.5.5 0 0 0 14 15.5V2a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2z"/>
                    </svg>
                </a>
                <button class="top-btn" id="themeToggle" onclick="toggleDarkMode()" title="Toggle dark mode">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" id="themeIcon">
                        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>
                    </svg>
                </button>
            </div>
            <!-- Font Settings -->
            <div class="font-settings-container" style="position: relative;">
                <button class="font-settings-btn" id="fontSettingsBtn" onclick="toggleFontSettings()" title="Font settings">
                    <span style="font-weight: bold;">Aa</span>
                </button>
                <div class="font-settings-panel" id="fontSettingsPanel">
                    <div class="font-size-control">
                        <label>Size</label>
                        <div class="font-size-buttons">
                            <button class="font-size-btn" onclick="changeFontSize(-1)" title="Decrease font size">‚àí</button>
                            <span class="font-size-value" id="fontSizeValue">18</span>
                            <button class="font-size-btn" onclick="changeFontSize(1)" title="Increase font size">+</button>
                        </div>
                    </div>
                    <div class="font-family-control">
                        <label>Font</label>
                        <div class="font-family-options">
                            <button class="font-family-option font-serif active" data-font="serif" onclick="changeFontFamily('serif')">
                                Georgia (Serif)
                            </button>
                            <button class="font-family-option font-sans" data-font="sans" onclick="changeFontFamily('sans')">
                                System (Sans-serif)
                            </button>
                            <button class="font-family-option font-mono" data-font="mono" onclick="changeFontFamily('mono')">
                                Monospace
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <article class="book-content" id="chapterContent">
                {{ current_chapter.content | safe }}
            </article>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>

            <!-- Undo Toast for Instant Highlight -->
            <div class="highlight-undo-toast" id="highlightUndoToast">
                <span>Highlighted</span>
                <button onclick="undoLastHighlight()">Undo</button>
            </div>

            <!-- Highlight Popup Menu -->
            <div class="highlight-popup" id="highlightPopup">
                <button onclick="copyHighlightText()">
                    <span>üìã</span> Copy
                </button>
                <button onclick="toggleNoteEditor()">
                    <span>üìù</span> <span id="noteButtonLabel">Add Note</span>
                </button>
                <div class="divider"></div>
                <button onclick="removeHighlight()" style="color: #dc3545;">
                    <span>üóëÔ∏è</span> Remove
                </button>
                <div class="note-editor" id="noteEditor">
                    <textarea id="noteInput" placeholder="Add your note here..."></textarea>
                    <button onclick="saveNote()">Save Note</button>
                </div>
            </div>

            <!-- Note Tooltip for Hover -->
            <div class="highlight-note-tooltip" id="noteTooltip"></div>
        </div>

        <!-- TTS Player Bar -->
        <div class="tts-player" id="ttsPlayer">
            <button class="tts-btn" id="ttsPlayPause" onclick="ttsPlayPause()" title="Play/Pause">‚è∏</button>
            <button class="tts-btn" onclick="ttsPrevParagraph()" title="Previous paragraph">‚óÄ‚óÄ</button>
            <button class="tts-btn" onclick="ttsNextParagraph()" title="Next paragraph">‚ñ∂‚ñ∂</button>
            <div class="tts-progress-container">
                <div class="tts-progress" id="ttsProgress">
                    <div class="tts-progress-fill" id="ttsProgressFill">
                        <div class="tts-progress-knob"></div>
                    </div>
                </div>
            </div>
            <span class="tts-time" id="ttsTime">0:00 / 0:00</span>
            <button class="tts-speed" id="ttsSpeed" onclick="toggleSpeedMenu()">1.0x</button>
            <button class="tts-pitch" id="ttsPitch" onclick="togglePitchMenu()" title="Pitch">1.0</button>
            <button class="tts-btn tts-close" onclick="closeTtsPlayer()" title="Close">‚úï</button>
        </div>

        <!-- TTS Speed Selection Popup -->
        <div class="tts-speed-popup" id="ttsSpeedPopup">
            <button onclick="setTtsSpeed(0.5)">0.5x</button>
            <button onclick="setTtsSpeed(0.75)">0.75x</button>
            <button onclick="setTtsSpeed(1.0)">1.0x</button>
            <button onclick="setTtsSpeed(1.25)">1.25x</button>
            <button onclick="setTtsSpeed(1.5)">1.5x</button>
            <button onclick="setTtsSpeed(2.0)">2.0x</button>
        </div>

        <!-- TTS Pitch Selection Popup -->
        <div class="tts-pitch-popup" id="ttsPitchPopup">
            <button onclick="setTtsPitch(0.5)">0.5</button>
            <button onclick="setTtsPitch(0.75)">0.75</button>
            <button onclick="setTtsPitch(1.0)">1.0</button>
            <button onclick="setTtsPitch(1.25)">1.25</button>
            <button onclick="setTtsPitch(1.5)">1.5</button>
        </div>
    </main>

    <script>
        // Highlight state
        let currentSelection = null;
        let currentHighlightId = null;
        let loadedHighlights = [];
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "{{ root_path }}/read/{{ book_id }}/" + idx;
                // If there's an anchor, preserve it in the URL hash
                if (anchor) {
                    url += "#" + anchor;
                }

                // Auto-close sidebar after clicking TOC link
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // On mobile, close the sidebar
                    document.body.classList.remove('sidebar-open');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                } else {
                    // On desktop, collapse the sidebar
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                }

                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        function scrollToAnchor() {
            // Check if there's a hash in the URL
            const hash = window.location.hash;
            if (hash) {
                // Remove the # to get the element ID
                const elementId = hash.substring(1);
                const targetElement = document.getElementById(elementId);

                if (targetElement) {
                    // Scroll within the #main container, not the window
                    setTimeout(() => {
                        const mainContainer = document.getElementById('main');
                        const containerRect = mainContainer.getBoundingClientRect();
                        const targetRect = targetElement.getBoundingClientRect();

                        // Calculate the scroll position: current scroll + target position relative to container
                        const scrollTo = mainContainer.scrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                        // Smooth scroll within the container
                        mainContainer.scrollTo({
                            top: scrollTo,
                            behavior: 'smooth'
                        });

                        // Add a temporary highlight to show where we scrolled
                        targetElement.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                        setTimeout(() => {
                            targetElement.style.backgroundColor = '';
                        }, 2000);
                    }, 100);
                } else {
                    console.log("Anchor element not found:", elementId);
                }
            }
        }

        function scrollSidebarToActive() {
            // Find the currently active TOC link
            const activeLink = document.querySelector('.toc-link.active');
            if (!activeLink) {
                console.log('scrollSidebarToActive: No active link found');
                return;
            }

            const sidebar = document.querySelector('#sidebar');
            if (!sidebar) {
                console.log('scrollSidebarToActive: No sidebar found');
                return;
            }

            console.log('scrollSidebarToActive: Scrolling to active item:', activeLink.textContent.trim().substring(0, 50));

            // Get positions
            const sidebarRect = sidebar.getBoundingClientRect();
            const linkRect = activeLink.getBoundingClientRect();

            // Calculate scroll position: current scroll + link position relative to sidebar - offset to center
            const scrollTo = sidebar.scrollTop + (linkRect.top - sidebarRect.top) - (sidebarRect.height / 3);

            console.log('scrollSidebarToActive: Current scroll:', sidebar.scrollTop, 'Target scroll:', Math.max(0, scrollTo));

            // Smooth scroll the sidebar
            sidebar.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
            });
        }

        function updateActiveTOCItem() {
            console.log('=== updateActiveTOCItem called ===');

            // Get current chapter index and hash from the URL
            const pathParts = window.location.pathname.split('/');
            const currentChapterIndex = parseInt(pathParts[pathParts.length - 1]);
            const currentHash = window.location.hash.substring(1); // Remove the #

            console.log('Current pathname:', window.location.pathname);
            console.log('Chapter index:', currentChapterIndex);
            console.log('Current hash:', currentHash);

            // Find the current chapter's href from spine
            const spineEntries = Object.entries(spineMap);
            const currentChapterFile = spineEntries.find(([file, idx]) => idx === currentChapterIndex)?.[0];

            console.log('Current chapter file:', currentChapterFile);

            if (!currentChapterFile) {
                console.log('ERROR: No chapter file found for index', currentChapterIndex);
                return;
            }

            // Build the full href we're looking for
            const targetHref = currentHash ? `${currentChapterFile}#${currentHash}` : currentChapterFile;
            console.log('Target href to match:', targetHref);

            // Remove active and active-parent class from all TOC links
            document.querySelectorAll('.toc-link').forEach(link => {
                link.classList.remove('active');
                link.classList.remove('active-parent');
            });

            // Find and activate the matching TOC link
            let matchFound = false;
            let activeLink = null;
            let firstChapterLink = null; // First link matching the chapter file (fallback)

            document.querySelectorAll('.toc-link').forEach(link => {
                const onclick = link.getAttribute('onclick');
                if (onclick) {
                    // Extract the href from onclick="findAndGo('...')"
                    const match = onclick.match(/findAndGo\('([^']+)'\)/);
                    if (match) {
                        const linkHref = match[1];
                        const linkBaseFile = linkHref.split('#')[0];

                        // Exact match (including anchor)
                        if (linkHref === targetHref) {
                            console.log('EXACT MATCH:', linkHref);
                            link.classList.add('active');
                            activeLink = link;
                            matchFound = true;
                        }
                        // Track first link for this chapter file (fallback)
                        else if (linkBaseFile === currentChapterFile && !firstChapterLink) {
                            firstChapterLink = link;
                        }
                    }
                }
            });

            // Fallback: if no exact match, highlight the first TOC entry for this chapter
            if (!matchFound && firstChapterLink) {
                console.log('FALLBACK MATCH:', firstChapterLink.textContent.trim().substring(0, 50));
                firstChapterLink.classList.add('active');
                activeLink = firstChapterLink;
                matchFound = true;
            }

            // If we found an active link, check if it's nested and highlight parent
            if (activeLink) {
                // Find parent chapter: go up through li.toc-item -> ul.toc-list -> li.toc-item
                const parentTocItem = activeLink.closest('li.toc-item');
                if (parentTocItem) {
                    const parentUl = parentTocItem.parentElement;
                    if (parentUl && parentUl.classList.contains('toc-list')) {
                        const grandparentTocItem = parentUl.closest('li.toc-item');
                        if (grandparentTocItem && grandparentTocItem !== parentTocItem) {
                            // Find the toc-link in the grandparent item (the parent chapter link)
                            const parentLink = grandparentTocItem.querySelector(':scope > a.toc-link');
                            if (parentLink) {
                                console.log('PARENT CHAPTER:', parentLink.textContent.trim().substring(0, 50));
                                parentLink.classList.add('active-parent');
                            }
                        }
                    }
                }
            }

            if (!matchFound) {
                console.log('WARNING: No matching TOC link found for', targetHref);
            }

            // Scroll sidebar to show the active item (with small delay to ensure DOM has updated)
            setTimeout(() => {
                scrollSidebarToActive();
            }, 100);
        }

        // Call scrollToAnchor when the page loads
        window.addEventListener('load', () => {
            scrollToAnchor();
            updateActiveTOCItem();
        });

        // Also call scrollToAnchor when navigating within the same page (hash changes)
        window.addEventListener('hashchange', () => {
            console.log('üîÑ hashchange event fired! New hash:', window.location.hash);
            scrollToAnchor();
            updateActiveTOCItem();
        });

        function copyChapter() {
            const content = document.getElementById('chapterContent');
            const text = content.innerText || content.textContent;

            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></svg>';
                btn.classList.add('copied');

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Dark Mode Functions
        function updateThemeIcon(isDark) {
            const icon = document.getElementById('themeIcon');
            if (isDark) {
                // Sun icon for dark mode (click to go light)
                icon.innerHTML = '<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path>';
            } else {
                // Moon icon for light mode (click to go dark)
                icon.innerHTML = '<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>';
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const isDark = body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcon(isDark);
        }

        function initTheme() {
            // Check localStorage first, then system preference
            let theme = localStorage.getItem('theme');
            if (!theme) {
                // Check system preference
                theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }

            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                updateThemeIcon(true);
            }
        }

        // Initialize theme on page load (before body renders to avoid flash)
        initTheme();

        // ===== FONT SETTINGS =====
        const fontFamilies = {
            serif: 'Georgia, "Times New Roman", serif',
            sans: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            mono: '"SF Mono", Menlo, Consolas, monospace'
        };

        let currentFontSize = 18;
        let currentFontFamily = 'serif';

        function toggleFontSettings() {
            const panel = document.getElementById('fontSettingsPanel');
            panel.classList.toggle('show');
        }

        function changeFontSize(delta) {
            const minSize = 12;
            const maxSize = 28;
            currentFontSize = Math.max(minSize, Math.min(maxSize, currentFontSize + delta));
            applyFontSettings();
            saveFontSettings();
        }

        function changeFontFamily(family) {
            currentFontFamily = family;

            // Update active button state
            document.querySelectorAll('.font-family-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.font === family) {
                    btn.classList.add('active');
                }
            });

            applyFontSettings();
            saveFontSettings();
        }

        function applyFontSettings() {
            const content = document.getElementById('chapterContent');
            content.style.fontSize = currentFontSize + 'px';
            content.style.fontFamily = fontFamilies[currentFontFamily];

            // Update the size display
            document.getElementById('fontSizeValue').textContent = currentFontSize;
        }

        function saveFontSettings() {
            localStorage.setItem('readerFontSize', currentFontSize);
            localStorage.setItem('readerFontFamily', currentFontFamily);
        }

        function loadFontSettings() {
            const savedSize = localStorage.getItem('readerFontSize');
            const savedFamily = localStorage.getItem('readerFontFamily');

            if (savedSize) {
                currentFontSize = parseInt(savedSize, 10);
            }
            if (savedFamily && fontFamilies[savedFamily]) {
                currentFontFamily = savedFamily;
            }

            // Update active button state
            document.querySelectorAll('.font-family-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.font === currentFontFamily) {
                    btn.classList.add('active');
                }
            });

            applyFontSettings();
        }

        // Initialize font settings
        loadFontSettings();

        // Close font panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('fontSettingsPanel');
            const btn = document.getElementById('fontSettingsBtn');
            if (!panel.contains(e.target) && !btn.contains(e.target)) {
                panel.classList.remove('show');
            }
        });

        // Sidebar Toggle Functions
        function updateSidebarIcon(isCollapsed) {
            const icon = document.getElementById('sidebarIcon');
            if (isCollapsed) {
                // Hamburger icon (sidebar closed - click to open)
                icon.innerHTML = '<path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>';
            } else {
                // Left arrow/chevron icon (sidebar open - click to close)
                icon.innerHTML = '<path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"></path>';
            }
        }

        function closeSidebar() {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                document.body.classList.remove('sidebar-open');
            } else {
                document.body.classList.add('sidebar-collapsed');
            }
            updateSidebarIcon(true);
            localStorage.setItem('sidebar', 'closed');
        }

        function toggleSidebar() {
            const body = document.body;
            const isMobile = window.innerWidth <= 768;

            if (isMobile) {
                // On mobile, toggle sidebar-open class
                const isOpen = body.classList.toggle('sidebar-open');
                localStorage.setItem('sidebar', isOpen ? 'open' : 'closed');
                updateSidebarIcon(!isOpen); // Icon shows opposite state

                // Scroll to active chapter when opening sidebar
                if (isOpen) {
                    setTimeout(scrollSidebarToActive, 100);
                }
            } else {
                // On desktop, toggle sidebar-collapsed class
                const isCollapsed = body.classList.toggle('sidebar-collapsed');
                localStorage.setItem('sidebar', isCollapsed ? 'closed' : 'open');
                updateSidebarIcon(isCollapsed);

                // Scroll to active chapter when opening sidebar
                if (!isCollapsed) {
                    setTimeout(scrollSidebarToActive, 100);
                }
            }
        }

        function initSidebar() {
            // Check localStorage and screen size
            let sidebarState = localStorage.getItem('sidebar');
            const isMobile = window.innerWidth <= 768;

            // Auto-collapse on mobile if no saved preference
            if (!sidebarState && isMobile) {
                sidebarState = 'closed';
            }

            if (isMobile) {
                // On mobile, use sidebar-open class
                if (sidebarState === 'open') {
                    document.body.classList.add('sidebar-open');
                    updateSidebarIcon(false);
                } else {
                    // Default: sidebar hidden on mobile (no sidebar-open class)
                    updateSidebarIcon(true);
                }
            } else {
                // On desktop, use sidebar-collapsed class
                if (sidebarState === 'closed') {
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                } else {
                    updateSidebarIcon(false);
                }
            }
        }

        // Initialize sidebar on page load
        initSidebar();

        // Auto-hide sidebar toggle button on mobile after inactivity
        if (window.innerWidth <= 768) {
            let hideTimeout;
            const sidebarToggle = document.getElementById('sidebarToggle');

            function resetHideTimer() {
                sidebarToggle.classList.remove('hidden');
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (!document.body.classList.contains('sidebar-open')) {
                        sidebarToggle.classList.add('hidden');
                    }
                }, 1000);
            }

            document.addEventListener('touchstart', resetHideTimer);
            document.addEventListener('touchmove', resetHideTimer);
            document.addEventListener('scroll', resetHideTimer, true);

            // Initial timer
            resetHideTimer();
        }

        // Keyboard shortcut: Cmd/Ctrl + Shift + P to toggle sidebar
        document.addEventListener('keydown', function(e) {
            // Check for Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux)
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'P' || e.key === 'p')) {
                e.preventDefault();
                toggleSidebar();
            }
        });

        // Keyboard navigation: Arrow keys for chapter navigation and scrolling
        document.addEventListener('keydown', function(e) {
            // Ignore if user is typing in an input field or textarea
            const activeEl = document.activeElement;
            if (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA') {
                return;
            }

            const mainContainer = document.getElementById('main');
            const scrollAmount = window.innerHeight * 0.8; // Scroll 80% of viewport height

            switch (e.key) {
                case 'ArrowLeft':
                    // Navigate to previous chapter
                    {% if prev_idx is not none %}
                    e.preventDefault();
                    window.location.href = "{{ root_path }}/read/{{ book_id }}/{{ prev_idx }}";
                    {% endif %}
                    break;
                case 'ArrowRight':
                    // Navigate to next chapter
                    {% if next_idx is not none %}
                    e.preventDefault();
                    window.location.href = "{{ root_path }}/read/{{ book_id }}/{{ next_idx }}";
                    {% endif %}
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    mainContainer.scrollBy({
                        top: -scrollAmount,
                        behavior: 'smooth'
                    });
                    break;
                case 'ArrowDown':
                case ' ':  // Spacebar
                    e.preventDefault();
                    mainContainer.scrollBy({
                        top: scrollAmount,
                        behavior: 'smooth'
                    });
                    break;
            }
        });

        // ===== HIGHLIGHTING SYSTEM =====

        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const chapterHref = "{{ current_chapter.href }}";

        // Load highlights for current chapter on page load
        async function loadHighlights() {
            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`);
                const data = await response.json();
                loadedHighlights = data.highlights.filter(h => h.chapter_index === chapterIndex);

                // Apply highlights to content
                loadedHighlights.forEach(highlight => {
                    applyHighlightToDOM(highlight);
                });

                // After highlights are applied, check if we need to scroll to a specific highlight
                scrollToHighlightFromHash();
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }

        // Scroll to a highlight if the URL hash contains a highlight ID
        function scrollToHighlightFromHash() {
            const hash = window.location.hash;
            if (!hash || !hash.startsWith('#highlight-')) return;

            const highlightId = hash.substring('#highlight-'.length);
            const highlightMark = document.querySelector(`mark[data-highlight-id="${highlightId}"]`);

            if (highlightMark) {
                scrollToElementAndHighlight(highlightMark);
            } else {
                // Fallback: try to scroll to the approximate position using offset
                const highlight = loadedHighlights.find(h => h.id === highlightId);
                if (highlight && highlight.start_offset) {
                    scrollToOffset(highlight.start_offset, highlight.text);
                } else {
                    console.log('Highlight not found:', highlightId);
                }
            }
        }

        // Helper function to scroll to an element and highlight it
        function scrollToElementAndHighlight(element) {
            const mainContainer = document.getElementById('main');
            const containerRect = mainContainer.getBoundingClientRect();
            const targetRect = element.getBoundingClientRect();

            // Calculate scroll position to center the highlight in view
            const scrollTo = mainContainer.scrollTop + (targetRect.top - containerRect.top) - (containerRect.height / 3);

            // Smooth scroll to the highlight
            mainContainer.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
            });

            // Add a temporary visual emphasis to show which highlight we scrolled to
            const originalBackground = element.style.backgroundColor;
            element.style.backgroundColor = '#ff6b6b';
            element.style.transition = 'background-color 0.3s';
            setTimeout(() => {
                element.style.backgroundColor = originalBackground || '';
                setTimeout(() => {
                    element.style.transition = '';
                }, 300);
            }, 2000);
        }

        // Scroll to a position in the content based on text offset
        function scrollToOffset(targetOffset, searchText) {
            const content = document.getElementById('chapterContent');
            const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null);

            let currentOffset = 0;
            let node;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeEndOffset = currentOffset + nodeLength;

                // Check if target offset falls within this node or text is found
                if (targetOffset < nodeEndOffset || node.textContent.includes(searchText)) {
                    // Found the approximate location - scroll to this node's parent element
                    let targetElement = node.parentElement;

                    // Try to find a better parent (paragraph, div, etc.)
                    while (targetElement && !['P', 'DIV', 'SECTION', 'ARTICLE', 'LI', 'BLOCKQUOTE'].includes(targetElement.tagName)) {
                        if (targetElement.parentElement && targetElement.parentElement.id !== 'chapterContent') {
                            targetElement = targetElement.parentElement;
                        } else {
                            break;
                        }
                    }

                    if (targetElement) {
                        scrollToElementAndHighlight(targetElement);
                    }
                    return;
                }

                currentOffset += nodeLength;
            }
        }

        // Apply a highlight to the DOM by wrapping text in <mark>
        function applyHighlightToDOM(highlight) {
            const content = document.getElementById('chapterContent');
            const fullText = content.textContent;
            const targetOffset = highlight.start_offset || 0;
            const highlightText = highlight.text;

            // Find the text at the specified offset
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let currentOffset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeStartOffset = currentOffset;
                const nodeEndOffset = currentOffset + nodeLength;

                // Check if our target offset falls within this node
                if (targetOffset >= nodeStartOffset && targetOffset < nodeEndOffset) {
                    const localOffset = targetOffset - nodeStartOffset;
                    const textInNode = node.textContent.substring(localOffset);

                    // Verify the text matches
                    if (textInNode.startsWith(highlightText)) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localOffset);

                            // Calculate end position (might span multiple nodes)
                            const endOffset = Math.min(localOffset + highlightText.length, nodeLength);
                            range.setEnd(node, endOffset);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight' + (highlight.note && highlight.note.trim() ? ' has-note' : '');
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            mark.addEventListener('mouseenter', (e) => showNoteTooltip(e, highlight.id));
                            mark.addEventListener('mouseleave', hideNoteTooltip);
                            found = true;
                            break;
                        } catch (e) {
                            console.warn('Could not apply highlight at offset', targetOffset, e);
                        }
                    }
                }

                currentOffset += nodeLength;
            }

            // Fallback: if offset-based matching failed, try simple text search
            if (!found) {
                currentOffset = 0;
                const walker2 = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null);
                while (node = walker2.nextNode()) {
                    const text = node.textContent;
                    const localIndex = text.indexOf(highlightText);

                    if (localIndex !== -1) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localIndex);
                            range.setEnd(node, localIndex + highlightText.length);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight' + (highlight.note && highlight.note.trim() ? ' has-note' : '');
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            mark.addEventListener('mouseenter', (e) => showNoteTooltip(e, highlight.id));
                            mark.addEventListener('mouseleave', hideNoteTooltip);
                            found = true;
                            break;
                        } catch (e) {
                            console.warn('Fallback highlight failed:', e);
                        }
                    }
                    currentOffset += text.length;
                }
            }

            return found;
        }

        // Text selection detection - Instant highlight on selection
        const chapterContent = document.getElementById('chapterContent');
        let lastHighlightId = null;
        let undoToastTimeout = null;

        // Create highlight when selection changes and user releases
        document.addEventListener('mouseup', handleSelectionEnd);
        document.addEventListener('touchend', (e) => {
            // Delay for mobile to let selection finalize
            setTimeout(() => handleSelectionEnd(e), 150);
        });

        function handleSelectionEnd(e) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            // Need at least 3 characters to highlight
            if (selectedText.length < 3) return;

            // Don't highlight if clicking on existing highlight or popup
            if (e && e.target && (e.target.closest('.highlight') || e.target.closest('.highlight-popup') || e.target.closest('.highlight-undo-toast'))) {
                return;
            }

            // Check if selection is within chapter content
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            if (!chapterContent.contains(range.commonAncestorContainer)) return;

            currentSelection = {
                text: selectedText,
                range: range.cloneRange()
            };

            // Get selection rect before we modify anything
            const rect = range.getBoundingClientRect();

            // Create highlight instantly
            createHighlightInstant(rect);
        }

        // Create highlight and show undo toast above selection
        async function createHighlightInstant(selectionRect) {
            if (!currentSelection) return;

            // Calculate the actual offset in the content
            const startOffset = calculateOffset(currentSelection.range);

            const highlightData = {
                text: currentSelection.text,
                chapter_index: chapterIndex,
                chapter_href: chapterHref,
                start_offset: startOffset,
                end_offset: startOffset + currentSelection.text.length,
                color: "yellow"
            };

            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(highlightData)
                });

                const result = await response.json();

                if (result.success) {
                    // Apply highlight to DOM
                    try {
                        const range = currentSelection.range;
                        const mark = document.createElement('mark');
                        mark.className = 'highlight';
                        mark.dataset.highlightId = result.highlight.id;
                        mark.dataset.note = '';

                        try {
                            range.surroundContents(mark);
                        } catch (e) {
                            const fragment = range.extractContents();
                            mark.appendChild(fragment);
                            range.insertNode(mark);
                        }

                        mark.addEventListener('click', (e) => showHighlightPopup(e, result.highlight.id));
                        mark.addEventListener('mouseenter', (e) => showNoteTooltip(e, result.highlight.id));
                        mark.addEventListener('mouseleave', hideNoteTooltip);

                        // Add to loaded highlights
                        loadedHighlights.push(result.highlight);

                        // Store for undo
                        lastHighlightId = result.highlight.id;

                        // Show undo toast above where the selection was
                        showUndoToast(selectionRect);

                    } catch (e) {
                        console.error('Failed to apply highlight:', e);
                    }

                    // Clear selection
                    window.getSelection().removeAllRanges();
                }
            } catch (error) {
                console.error('Failed to create highlight:', error);
            }
        }

        function showUndoToast(selectionRect) {
            const toast = document.getElementById('highlightUndoToast');
            const containerRect = document.querySelector('.content-container').getBoundingClientRect();

            // Position above the selection
            toast.classList.remove('fade-out');
            toast.classList.add('show');

            // Get toast dimensions after showing
            const toastRect = toast.getBoundingClientRect();

            // Calculate position: above the selection, centered horizontally
            let top = selectionRect.top - containerRect.top - toastRect.height - 8;
            let left = selectionRect.left - containerRect.left + (selectionRect.width / 2) - (toastRect.width / 2);

            // Keep within container bounds
            left = Math.max(0, Math.min(left, containerRect.width - toastRect.width));

            // If would go above viewport, show below instead
            if (top < -containerRect.top + 10) {
                top = selectionRect.bottom - containerRect.top + 8;
            }

            toast.style.top = `${top}px`;
            toast.style.left = `${left}px`;

            // Auto-hide after 4 seconds
            clearTimeout(undoToastTimeout);
            undoToastTimeout = setTimeout(() => {
                hideUndoToast();
            }, 4000);
        }

        function hideUndoToast() {
            const toast = document.getElementById('highlightUndoToast');
            toast.classList.add('fade-out');
            setTimeout(() => {
                toast.classList.remove('show', 'fade-out');
            }, 200);
            clearTimeout(undoToastTimeout);
        }

        async function undoLastHighlight() {
            if (!lastHighlightId) return;

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${lastHighlightId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from DOM
                    const mark = document.querySelector(`[data-highlight-id="${lastHighlightId}"]`);
                    if (mark) {
                        const parent = mark.parentNode;
                        while (mark.firstChild) {
                            parent.insertBefore(mark.firstChild, mark);
                        }
                        parent.removeChild(mark);
                        // Normalize to merge adjacent text nodes
                        parent.normalize();
                    }

                    // Remove from cache
                    loadedHighlights = loadedHighlights.filter(h => h.id !== lastHighlightId);
                    lastHighlightId = null;

                    hideUndoToast();
                }
            } catch (error) {
                console.error('Failed to undo highlight:', error);
            }
        }

        // Calculate offset of a range in the content
        function calculateOffset(range) {
            const content = document.getElementById('chapterContent');
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let offset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                if (node === range.startContainer) {
                    offset += range.startOffset;
                    found = true;
                    break;
                }
                offset += node.textContent.length;
            }

            return found ? offset : 0;
        }

        // Show popup menu for existing highlight
        function showHighlightPopup(e, highlightId) {
            e.stopPropagation();

            currentHighlightId = highlightId;

            const highlight = loadedHighlights.find(h => h.id === highlightId);
            if (!highlight) return;

            // Update note button label
            const noteLabel = document.getElementById('noteButtonLabel');
            noteLabel.textContent = highlight.note ? 'Edit Note' : 'Add Note';

            // Position popup
            const popup = document.getElementById('highlightPopup');
            const rect = e.target.getBoundingClientRect();
            const containerRect = document.querySelector('.content-container').getBoundingClientRect();

            // Position relative to the content-container
            // Both rect and containerRect are viewport-relative, so their difference
            // gives us the position within the container (which is the popup's offsetParent)
            popup.style.top = `${rect.bottom - containerRect.top + 5}px`;
            popup.style.left = `${rect.left - containerRect.left}px`;
            popup.classList.add('show');

            // Hide note editor initially
            document.getElementById('noteEditor').classList.remove('show');
        }

        function hideHighlightPopup() {
            document.getElementById('highlightPopup').classList.remove('show');
            document.getElementById('noteEditor').classList.remove('show');
            currentHighlightId = null;
        }

        // Note tooltip on hover
        function showNoteTooltip(e, highlightId) {
            const highlight = loadedHighlights.find(h => h.id === highlightId);
            if (!highlight || !highlight.note || !highlight.note.trim()) return;

            const tooltip = document.getElementById('noteTooltip');
            tooltip.textContent = highlight.note;

            // Position above the highlight
            const rect = e.target.getBoundingClientRect();
            const containerRect = document.querySelector('.content-container').getBoundingClientRect();

            // First show tooltip to get its height
            tooltip.style.visibility = 'hidden';
            tooltip.classList.add('show');
            const tooltipHeight = tooltip.offsetHeight;

            tooltip.style.left = `${rect.left - containerRect.left}px`;
            tooltip.style.top = `${rect.top - containerRect.top - tooltipHeight - 8}px`;
            tooltip.style.visibility = 'visible';
        }

        function hideNoteTooltip() {
            document.getElementById('noteTooltip').classList.remove('show');
        }

        // Copy highlight text to clipboard
        function copyHighlightText() {
            const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
            if (!highlight) return;

            navigator.clipboard.writeText(highlight.text).then(() => {
                alert('Copied to clipboard!');
                hideHighlightPopup();
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Toggle note editor
        function toggleNoteEditor() {
            const editor = document.getElementById('noteEditor');
            const input = document.getElementById('noteInput');

            if (editor.classList.contains('show')) {
                editor.classList.remove('show');
            } else {
                // Load existing note
                const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                input.value = highlight?.note || '';
                editor.classList.add('show');
                input.focus();
            }
        }

        // Save note
        async function saveNote() {
            const note = document.getElementById('noteInput').value.trim();

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({note: note})
                });

                const result = await response.json();

                if (result.success) {
                    // Update local cache
                    const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                    if (highlight) {
                        highlight.note = note;
                    }

                    // Update DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        mark.dataset.note = note;
                        // Update has-note class based on whether note exists
                        if (note) {
                            mark.classList.add('has-note');
                        } else {
                            mark.classList.remove('has-note');
                        }
                    }

                    alert('Note saved!');
                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                alert('Failed to save note. Please try again.');
            }
        }

        // Remove highlight
        async function removeHighlight() {
            if (!confirm('Remove this highlight?')) return;

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        const parent = mark.parentNode;
                        while (mark.firstChild) {
                            parent.insertBefore(mark.firstChild, mark);
                        }
                        parent.removeChild(mark);
                    }

                    // Remove from cache
                    loadedHighlights = loadedHighlights.filter(h => h.id !== currentHighlightId);

                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to remove highlight:', error);
                alert('Failed to remove highlight. Please try again.');
            }
        }

        // Click outside to hide popups
        // Hide popups/toolbars when clicking/touching outside
        function handleOutsideInteraction(e) {
            if (!e.target.closest('.highlight-popup') && !e.target.closest('.highlight')) {
                hideHighlightPopup();
            }
            // Don't hide undo toast here - it has its own auto-hide timer
            // and we don't want to interfere with the highlight creation flow

            // Close/collapse sidebar when clicking on main content area
            const isMobile = window.innerWidth <= 768;
            const clickedOnMain = e.target.closest('#main');
            const clickedOutsideSidebar = !e.target.closest('#sidebar') && !e.target.closest('.sidebar-toggle');

            if (clickedOutsideSidebar && clickedOnMain) {
                if (isMobile && document.body.classList.contains('sidebar-open')) {
                    // On mobile, close the sidebar overlay
                    document.body.classList.remove('sidebar-open');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                } else if (!isMobile && !document.body.classList.contains('sidebar-collapsed')) {
                    // On desktop, collapse the sidebar
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                }
            }
        }

        document.addEventListener('click', handleOutsideInteraction);
        document.addEventListener('touchend', handleOutsideInteraction);

        // Load highlights when page is ready
        window.addEventListener('load', loadHighlights);

        // ===== READING PROGRESS TRACKING =====
        const totalChapters = {{ book.spine|length }};

        // Restore scroll position when returning to a chapter
        let scrollRestored = false;
        async function restoreScrollPosition() {
            // Don't restore if there's a hash anchor (user clicked a specific TOC item)
            if (window.location.hash) {
                scrollRestored = true;
                return;
            }

            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/progress`);
                const progress = await response.json();

                // Only restore if we're on the same chapter that was saved
                if (progress.chapter_index === chapterIndex && progress.scroll_percent > 0.01) {
                    const mainContainer = document.getElementById('main');
                    const scrollableHeight = mainContainer.scrollHeight - mainContainer.clientHeight;
                    const targetScroll = progress.scroll_percent * scrollableHeight;

                    // Small delay to ensure content is fully rendered
                    setTimeout(() => {
                        mainContainer.scrollTo({
                            top: targetScroll,
                            behavior: 'instant'
                        });
                        scrollRestored = true;
                    }, 100);
                } else {
                    scrollRestored = true;
                }
            } catch (err) {
                console.error('Failed to restore scroll position:', err);
                scrollRestored = true;
            }
        }

        // Restore scroll position on page load
        window.addEventListener('load', restoreScrollPosition);

        function saveProgress() {
            const mainContainer = document.getElementById('main');
            const scrollPercent = mainContainer.scrollTop / (mainContainer.scrollHeight - mainContainer.clientHeight);
            const clampedScroll = Math.min(1, Math.max(0, scrollPercent || 0));

            fetch(`{{ root_path }}/api/books/${bookId}/progress`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chapter_index: chapterIndex,
                    scroll_percent: clampedScroll,
                    total_chapters: totalChapters
                })
            }).catch(err => console.error('Failed to save progress:', err));
        }

        // Debounce scroll saves
        let progressTimeout = null;
        document.getElementById('main').addEventListener('scroll', () => {
            if (progressTimeout) clearTimeout(progressTimeout);
            progressTimeout = setTimeout(saveProgress, 1000);
        });

        // Save progress on page unload
        window.addEventListener('beforeunload', saveProgress);

        // Save progress on chapter load (after scroll restoration completes)
        window.addEventListener('load', () => {
            // Wait for scroll restoration before saving, to avoid overwriting with 0%
            const waitForRestore = setInterval(() => {
                if (scrollRestored) {
                    clearInterval(waitForRestore);
                    setTimeout(saveProgress, 200);
                }
            }, 50);
            // Fallback: save after 2 seconds regardless
            setTimeout(() => {
                clearInterval(waitForRestore);
                saveProgress();
            }, 2000);
        });
    </script>

    <!-- TTS Scripts -->
    <script src="{{ root_path }}/static/tts/tts-segmenter.js"></script>
    <script src="{{ root_path }}/static/tts/tts.js"></script>
    <script src="{{ root_path }}/static/tts/tts-player.js"></script>
    <script>
        // Initialize TTS Player with book context
        window.addEventListener('load', () => {
            TtsPlayer.init("{{ book_id }}", {{ chapter_index }});
        });
    </script>
</body>
</html>
