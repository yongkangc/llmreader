<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Theme Variables */
        :root {
            --bg-main: #ffffff;
            --bg-sidebar: #f8f9fa;
            --bg-button: #f8f9fa;
            --bg-button-hover: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --border-light: #e9ecef;
            --border-medium: #dee2e6;
            --border-dark: #adb5bd;
            --accent-primary: #3498db;
            --accent-success: #28a745;
            --accent-active: #d63384;
            --heading-color: #333333;
        }

        body.dark-mode {
            --bg-main: #1a1a1a;
            --bg-sidebar: #2d2d2d;
            --bg-button: #3d3d3d;
            --bg-button-hover: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --border-light: #3d3d3d;
            --border-medium: #4a4a4a;
            --border-dark: #5a5a5a;
            --accent-primary: #7db8f5;
            --accent-success: #98c379;
            --accent-active: #e06c75;
            --heading-color: #d4d4d4;
        }

        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: var(--bg-main); transition: background-color 0.3s, color 0.3s; }

        /* Sidebar */
        #sidebar { width: 300px; background: var(--bg-sidebar); border-right: 1px solid var(--border-light); overflow-y: auto; padding: 20px; flex-shrink: 0; transition: transform 0.3s ease, width 0.3s ease, padding 0.3s ease, background-color 0.3s, border-color 0.3s; position: relative; z-index: 10; }

        /* Sidebar Collapsed State */
        body.sidebar-collapsed #sidebar { transform: translateX(-100%); width: 0; padding: 0; border-right: none; overflow: hidden; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: var(--text-secondary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-medium); transition: color 0.3s, border-color 0.3s; }
        .nav-home { display: block; margin-bottom: 20px; color: var(--accent-primary); text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; transition: color 0.3s; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: var(--text-secondary); font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; transition: color 0.3s; }
        a.toc-link:hover { color: var(--text-primary); text-decoration: underline; }
        a.toc-link.active { color: var(--accent-active); font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; background: var(--bg-main); transition: background-color 0.3s; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: var(--text-primary); position: relative; transition: max-width 0.3s ease, color 0.3s; }

        /* Expand content when sidebar is collapsed */
        body.sidebar-collapsed .content-container { max-width: 900px; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: var(--heading-color); transition: color 0.3s; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; color: var(--text-primary); transition: color 0.3s; }

        /* Copy Button */
        .copy-btn { position: absolute; top: 20px; right: 100px; background: var(--bg-button); color: var(--text-secondary); border: 1px solid var(--border-medium); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; }
        .copy-btn:hover { background: var(--bg-button-hover); border-color: var(--border-dark); }
        .copy-btn.copied { background: var(--accent-success); color: white; border-color: var(--accent-success); }

        /* Sidebar Toggle */
        .sidebar-toggle { position: fixed; top: 20px; left: 20px; background: var(--bg-button); color: var(--text-secondary); border: 1px solid var(--border-medium); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; z-index: 20; }
        .sidebar-toggle:hover { background: var(--bg-button-hover); border-color: var(--border-dark); }
        body.sidebar-collapsed .sidebar-toggle { left: auto; right: 160px; }

        /* Dark Mode Toggle */
        .theme-toggle { position: absolute; top: 20px; right: 40px; background: var(--bg-button); color: var(--text-secondary); border: 1px solid var(--border-medium); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; }
        .theme-toggle:hover { background: var(--bg-button-hover); border-color: var(--border-dark); }

        /* Responsive: Auto-collapse sidebar on mobile */
        @media (max-width: 768px) {
            /* On mobile, sidebar becomes an overlay */
            #sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 300px;
                z-index: 30;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }

            /* Show sidebar when open */
            body.sidebar-open #sidebar {
                transform: translateX(0);
            }

            /* Main content takes full width on mobile */
            #main {
                width: 100%;
            }

            /* Adjust content padding on mobile */
            .content-container {
                max-width: 100%;
                padding: 60px 20px;
            }

            /* Sidebar toggle button position on mobile */
            .sidebar-toggle {
                left: 10px;
                top: 10px;
                opacity: 1;
                transition: opacity 0.3s ease;
            }

            /* Auto-hide sidebar toggle on mobile */
            .sidebar-toggle.hidden {
                opacity: 0;
                pointer-events: none;
            }

            body.sidebar-collapsed .sidebar-toggle {
                left: 10px;
                right: auto;
            }

            /* Backdrop when sidebar is open on mobile */
            body.sidebar-open::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 25;
            }
        }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid var(--border-light); font-family: -apple-system, sans-serif; transition: border-color 0.3s; }
        .nav-btn { text-decoration: none; color: var(--accent-primary); font-weight: bold; padding: 10px 20px; border: 1px solid var(--accent-primary); border-radius: 4px; transition: all 0.3s; }
        .nav-btn:hover { background: var(--accent-primary); color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: var(--border-dark); color: var(--text-muted); }

        /* Highlights */
        mark.highlight {
            background-color: #ffeb3b;
            cursor: pointer;
            padding: 2px 0;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        mark.highlight:hover {
            background-color: #ffd700;
        }
        body.dark-mode mark.highlight {
            background-color: #b8860b;
            color: var(--text-primary);
        }
        body.dark-mode mark.highlight:hover {
            background-color: #daa520;
        }

        /* Floating Highlight Toolbar */
        .highlight-toolbar {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            font-family: -apple-system, sans-serif;
        }
        .highlight-toolbar.show {
            display: block;
        }
        .highlight-toolbar button {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }
        .highlight-toolbar button:hover {
            background: var(--accent-success);
            transform: scale(1.05);
        }

        /* Highlight Popup Menu */
        .highlight-popup {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 4px;
            z-index: 1000;
            display: none;
            font-family: -apple-system, sans-serif;
        }
        .highlight-popup.show {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .highlight-popup button {
            background: transparent;
            color: var(--text-primary);
            border: none;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9em;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        .highlight-popup button:hover {
            background: var(--bg-button-hover);
        }
        .highlight-popup .divider {
            height: 1px;
            background: var(--border-light);
            margin: 4px 0;
        }

        /* Note Editor in Popup */
        .note-editor {
            padding: 8px;
            display: none;
        }
        .note-editor.show {
            display: block;
        }
        .note-editor textarea {
            width: 250px;
            min-height: 60px;
            padding: 8px;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
            background: var(--bg-main);
            color: var(--text-primary);
            resize: vertical;
        }
        .note-editor button {
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .note-editor button:hover {
            background: var(--accent-success);
        }

    </style>
</head>
<body>
    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="Toggle sidebar">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" id="sidebarIcon">
            <!-- Hamburger icon (default - sidebar open) -->
            <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
        </svg>
    </button>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="{{ root_path }}/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <button class="copy-btn" id="copyBtn" onclick="copyChapter()" title="Copy to clipboard for LLM">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Z"></path>
                    <path d="M2 6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-1h-1v1a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h1V6H2Z"></path>
                </svg>
            </button>
            <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()" title="Toggle dark mode">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" id="themeIcon">
                    <!-- Moon icon (default for light mode) -->
                    <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>
                </svg>
            </button>
            <div class="book-content" id="chapterContent">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>

            <!-- Floating Highlight Toolbar -->
            <div class="highlight-toolbar" id="highlightToolbar">
                <button onclick="createHighlight()">‚ú® Highlight</button>
            </div>

            <!-- Highlight Popup Menu -->
            <div class="highlight-popup" id="highlightPopup">
                <button onclick="copyHighlightText()">
                    <span>üìã</span> Copy
                </button>
                <button onclick="toggleNoteEditor()">
                    <span>üìù</span> <span id="noteButtonLabel">Add Note</span>
                </button>
                <div class="divider"></div>
                <button onclick="removeHighlight()" style="color: #dc3545;">
                    <span>üóëÔ∏è</span> Remove
                </button>
                <div class="note-editor" id="noteEditor">
                    <textarea id="noteInput" placeholder="Add your note here..."></textarea>
                    <button onclick="saveNote()">Save Note</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Highlight state
        let currentSelection = null;
        let currentHighlightId = null;
        let loadedHighlights = [];
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "{{ root_path }}/read/{{ book_id }}/" + idx;
                // If there's an anchor, preserve it in the URL hash
                if (anchor) {
                    url += "#" + anchor;
                }
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        function scrollToAnchor() {
            // Check if there's a hash in the URL
            const hash = window.location.hash;
            if (hash) {
                // Remove the # to get the element ID
                const elementId = hash.substring(1);
                const targetElement = document.getElementById(elementId);

                if (targetElement) {
                    // Scroll within the #main container, not the window
                    setTimeout(() => {
                        const mainContainer = document.getElementById('main');
                        const containerRect = mainContainer.getBoundingClientRect();
                        const targetRect = targetElement.getBoundingClientRect();

                        // Calculate the scroll position: current scroll + target position relative to container
                        const scrollTo = mainContainer.scrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                        // Smooth scroll within the container
                        mainContainer.scrollTo({
                            top: scrollTo,
                            behavior: 'smooth'
                        });

                        // Add a temporary highlight to show where we scrolled
                        targetElement.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                        setTimeout(() => {
                            targetElement.style.backgroundColor = '';
                        }, 2000);
                    }, 100);
                } else {
                    console.log("Anchor element not found:", elementId);
                }
            }
        }

        function scrollSidebarToActive() {
            // Find the currently active TOC link
            const activeLink = document.querySelector('.toc-link.active');
            if (!activeLink) {
                console.log('scrollSidebarToActive: No active link found');
                return;
            }

            const sidebar = document.querySelector('#sidebar');
            if (!sidebar) {
                console.log('scrollSidebarToActive: No sidebar found');
                return;
            }

            console.log('scrollSidebarToActive: Scrolling to active item:', activeLink.textContent.trim().substring(0, 50));

            // Get positions
            const sidebarRect = sidebar.getBoundingClientRect();
            const linkRect = activeLink.getBoundingClientRect();

            // Calculate scroll position: current scroll + link position relative to sidebar - offset to center
            const scrollTo = sidebar.scrollTop + (linkRect.top - sidebarRect.top) - (sidebarRect.height / 3);

            console.log('scrollSidebarToActive: Current scroll:', sidebar.scrollTop, 'Target scroll:', Math.max(0, scrollTo));

            // Smooth scroll the sidebar
            sidebar.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
            });
        }

        function updateActiveTOCItem() {
            console.log('=== updateActiveTOCItem called ===');

            // Get current chapter index and hash from the URL
            const pathParts = window.location.pathname.split('/');
            const currentChapterIndex = parseInt(pathParts[pathParts.length - 1]);
            const currentHash = window.location.hash.substring(1); // Remove the #

            console.log('Current pathname:', window.location.pathname);
            console.log('Chapter index:', currentChapterIndex);
            console.log('Current hash:', currentHash);

            // Find the current chapter's href from spine
            const spineEntries = Object.entries(spineMap);
            const currentChapterFile = spineEntries.find(([file, idx]) => idx === currentChapterIndex)?.[0];

            console.log('Current chapter file:', currentChapterFile);

            if (!currentChapterFile) {
                console.log('ERROR: No chapter file found for index', currentChapterIndex);
                return;
            }

            // Build the full href we're looking for
            const targetHref = currentHash ? `${currentChapterFile}#${currentHash}` : currentChapterFile;
            console.log('Target href to match:', targetHref);

            // Remove active class from all TOC links
            document.querySelectorAll('.toc-link').forEach(link => {
                link.classList.remove('active');
            });

            // Find and activate the matching TOC link
            let matchFound = false;
            document.querySelectorAll('.toc-link').forEach(link => {
                const onclick = link.getAttribute('onclick');
                if (onclick) {
                    // Extract the href from onclick="findAndGo('...')"
                    const match = onclick.match(/findAndGo\('([^']+)'\)/);
                    if (match) {
                        const linkHref = match[1];
                        if (linkHref === targetHref) {
                            console.log('MATCH FOUND:', linkHref, link.textContent.trim().substring(0, 50));
                            link.classList.add('active');
                            matchFound = true;
                        }
                    }
                }
            });

            if (!matchFound) {
                console.log('WARNING: No matching TOC link found for', targetHref);
            }

            // Scroll sidebar to show the active item (with small delay to ensure DOM has updated)
            setTimeout(() => {
                scrollSidebarToActive();
            }, 100);
        }

        // Call scrollToAnchor when the page loads
        window.addEventListener('load', () => {
            scrollToAnchor();
            updateActiveTOCItem();
        });

        // Also call scrollToAnchor when navigating within the same page (hash changes)
        window.addEventListener('hashchange', () => {
            console.log('üîÑ hashchange event fired! New hash:', window.location.hash);
            scrollToAnchor();
            updateActiveTOCItem();
        });

        function copyChapter() {
            const content = document.getElementById('chapterContent');
            const text = content.innerText || content.textContent;

            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></svg>';
                btn.classList.add('copied');

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Dark Mode Functions
        function updateThemeIcon(isDark) {
            const icon = document.getElementById('themeIcon');
            if (isDark) {
                // Sun icon for dark mode (click to go light)
                icon.innerHTML = '<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path>';
            } else {
                // Moon icon for light mode (click to go dark)
                icon.innerHTML = '<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>';
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const isDark = body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcon(isDark);
        }

        function initTheme() {
            // Check localStorage first, then system preference
            let theme = localStorage.getItem('theme');
            if (!theme) {
                // Check system preference
                theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }

            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                updateThemeIcon(true);
            }
        }

        // Initialize theme on page load (before body renders to avoid flash)
        initTheme();

        // Sidebar Toggle Functions
        function updateSidebarIcon(isCollapsed) {
            const icon = document.getElementById('sidebarIcon');
            if (isCollapsed) {
                // Hamburger icon (sidebar closed - click to open)
                icon.innerHTML = '<path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>';
            } else {
                // Left arrow/chevron icon (sidebar open - click to close)
                icon.innerHTML = '<path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"></path>';
            }
        }

        function toggleSidebar() {
            const body = document.body;
            const isMobile = window.innerWidth <= 768;

            if (isMobile) {
                // On mobile, toggle sidebar-open class
                const isOpen = body.classList.toggle('sidebar-open');
                localStorage.setItem('sidebar', isOpen ? 'open' : 'closed');
                updateSidebarIcon(!isOpen); // Icon shows opposite state
            } else {
                // On desktop, toggle sidebar-collapsed class
                const isCollapsed = body.classList.toggle('sidebar-collapsed');
                localStorage.setItem('sidebar', isCollapsed ? 'closed' : 'open');
                updateSidebarIcon(isCollapsed);
            }
        }

        function initSidebar() {
            // Check localStorage and screen size
            let sidebarState = localStorage.getItem('sidebar');
            const isMobile = window.innerWidth <= 768;

            // Auto-collapse on mobile if no saved preference
            if (!sidebarState && isMobile) {
                sidebarState = 'closed';
            }

            if (isMobile) {
                // On mobile, use sidebar-open class
                if (sidebarState === 'open') {
                    document.body.classList.add('sidebar-open');
                    updateSidebarIcon(false);
                } else {
                    // Default: sidebar hidden on mobile (no sidebar-open class)
                    updateSidebarIcon(true);
                }
            } else {
                // On desktop, use sidebar-collapsed class
                if (sidebarState === 'closed') {
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                } else {
                    updateSidebarIcon(false);
                }
            }
        }

        // Initialize sidebar on page load
        initSidebar();

        // Auto-hide sidebar toggle button on mobile after inactivity
        if (window.innerWidth <= 768) {
            let hideTimeout;
            const sidebarToggle = document.getElementById('sidebarToggle');

            function resetHideTimer() {
                sidebarToggle.classList.remove('hidden');
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (!document.body.classList.contains('sidebar-open')) {
                        sidebarToggle.classList.add('hidden');
                    }
                }, 1000);
            }

            document.addEventListener('touchstart', resetHideTimer);
            document.addEventListener('touchmove', resetHideTimer);
            document.addEventListener('scroll', resetHideTimer, true);

            // Initial timer
            resetHideTimer();
        }

        // Keyboard shortcut: Cmd/Ctrl + Shift + P to toggle sidebar
        document.addEventListener('keydown', function(e) {
            // Check for Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux)
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'P' || e.key === 'p')) {
                e.preventDefault();
                toggleSidebar();
            }
        });

        // ===== HIGHLIGHTING SYSTEM =====

        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const chapterHref = "{{ current_chapter.href }}";

        // Load highlights for current chapter on page load
        async function loadHighlights() {
            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`);
                const data = await response.json();
                loadedHighlights = data.highlights.filter(h => h.chapter_index === chapterIndex);

                // Apply highlights to content
                loadedHighlights.forEach(highlight => {
                    applyHighlightToDOM(highlight);
                });
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }

        // Apply a highlight to the DOM by wrapping text in <mark>
        function applyHighlightToDOM(highlight) {
            const content = document.getElementById('chapterContent');
            const fullText = content.textContent;
            const targetOffset = highlight.start_offset || 0;
            const highlightText = highlight.text;

            // Find the text at the specified offset
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let currentOffset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeStartOffset = currentOffset;
                const nodeEndOffset = currentOffset + nodeLength;

                // Check if our target offset falls within this node
                if (targetOffset >= nodeStartOffset && targetOffset < nodeEndOffset) {
                    const localOffset = targetOffset - nodeStartOffset;
                    const textInNode = node.textContent.substring(localOffset);

                    // Verify the text matches
                    if (textInNode.startsWith(highlightText)) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localOffset);

                            // Calculate end position (might span multiple nodes)
                            const endOffset = Math.min(localOffset + highlightText.length, nodeLength);
                            range.setEnd(node, endOffset);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight';
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            found = true;
                            break;
                        } catch (e) {
                            console.warn('Could not apply highlight at offset', targetOffset, e);
                        }
                    }
                }

                currentOffset += nodeLength;
            }

            // Fallback: if offset-based matching failed, try simple text search
            if (!found) {
                currentOffset = 0;
                const walker2 = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null);
                while (node = walker2.nextNode()) {
                    const text = node.textContent;
                    const localIndex = text.indexOf(highlightText);

                    if (localIndex !== -1 && currentOffset + localIndex >= targetOffset) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localIndex);
                            range.setEnd(node, localIndex + highlightText.length);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight';
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            break;
                        } catch (e) {
                            console.warn('Fallback highlight failed:', e);
                        }
                    }
                    currentOffset += text.length;
                }
            }
        }

        // Text selection detection
        // Listen for both mouse and touch events for text selection
        const chapterContent = document.getElementById('chapterContent');
        chapterContent.addEventListener('mouseup', handleTextSelection);

        // On mobile, use selectionchange with debouncing
        let selectionTimeout;
        document.addEventListener('selectionchange', () => {
            clearTimeout(selectionTimeout);
            selectionTimeout = setTimeout(() => {
                const selection = window.getSelection();
                if (selection.toString().trim().length > 0) {
                    // Check if the selection is within our chapter content
                    const range = selection.getRangeAt(0);
                    if (chapterContent.contains(range.commonAncestorContainer)) {
                        handleTextSelection();
                    }
                }
            }, 300); // Wait 300ms after selection changes stop
        });

        function handleTextSelection(e) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 0) {
                currentSelection = {
                    text: selectedText,
                    range: selection.getRangeAt(0).cloneRange()
                };

                // Show highlight button near selection
                const rect = selection.getRangeAt(0).getBoundingClientRect();
                const toolbar = document.getElementById('highlightToolbar');
                const containerRect = document.querySelector('.content-container').getBoundingClientRect();

                // Position relative to the content-container
                // Both rect and containerRect are viewport-relative, so their difference
                // gives us the position within the container (which is the toolbar's offsetParent)
                toolbar.style.top = `${rect.bottom - containerRect.top + 5}px`;
                toolbar.style.left = `${rect.left - containerRect.left}px`;
                toolbar.classList.add('show');
            } else {
                hideHighlightToolbar();
            }
        }

        function hideHighlightToolbar() {
            document.getElementById('highlightToolbar').classList.remove('show');
        }

        // Calculate offset of a range in the content
        function calculateOffset(range) {
            const content = document.getElementById('chapterContent');
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let offset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                if (node === range.startContainer) {
                    offset += range.startOffset;
                    found = true;
                    break;
                }
                offset += node.textContent.length;
            }

            return found ? offset : 0;
        }

        // Create a new highlight
        async function createHighlight() {
            if (!currentSelection) return;

            // Calculate the actual offset in the content
            const startOffset = calculateOffset(currentSelection.range);

            const highlightData = {
                text: currentSelection.text,
                chapter_index: chapterIndex,
                chapter_href: chapterHref,
                start_offset: startOffset,
                end_offset: startOffset + currentSelection.text.length,
                color: "yellow"
            };

            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(highlightData)
                });

                const result = await response.json();

                if (result.success) {
                    // Apply highlight to DOM using more robust method
                    try {
                        const range = currentSelection.range;
                        const mark = document.createElement('mark');
                        mark.className = 'highlight';
                        mark.dataset.highlightId = result.highlight.id;
                        mark.dataset.note = '';

                        // Try simple surroundContents first (works for single-element selections)
                        try {
                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, result.highlight.id));
                        } catch (e) {
                            // If that fails (selection crosses elements), use extractContents + appendChild
                            const fragment = range.extractContents();
                            mark.appendChild(fragment);
                            range.insertNode(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, result.highlight.id));
                        }

                        // Add to loaded highlights
                        loadedHighlights.push(result.highlight);
                    } catch (e) {
                        console.error('Failed to apply highlight:', e);
                        alert('Failed to apply highlight. Please try selecting within a single paragraph.');
                    }

                    // Clear selection
                    window.getSelection().removeAllRanges();
                    hideHighlightToolbar();
                }
            } catch (error) {
                console.error('Failed to create highlight:', error);
                alert('Failed to create highlight. Please try again.');
            }
        }

        // Show popup menu for existing highlight
        function showHighlightPopup(e, highlightId) {
            e.stopPropagation();

            currentHighlightId = highlightId;

            const highlight = loadedHighlights.find(h => h.id === highlightId);
            if (!highlight) return;

            // Update note button label
            const noteLabel = document.getElementById('noteButtonLabel');
            noteLabel.textContent = highlight.note ? 'Edit Note' : 'Add Note';

            // Position popup
            const popup = document.getElementById('highlightPopup');
            const rect = e.target.getBoundingClientRect();
            const containerRect = document.querySelector('.content-container').getBoundingClientRect();

            // Position relative to the content-container
            // Both rect and containerRect are viewport-relative, so their difference
            // gives us the position within the container (which is the popup's offsetParent)
            popup.style.top = `${rect.bottom - containerRect.top + 5}px`;
            popup.style.left = `${rect.left - containerRect.left}px`;
            popup.classList.add('show');

            // Hide note editor initially
            document.getElementById('noteEditor').classList.remove('show');
        }

        function hideHighlightPopup() {
            document.getElementById('highlightPopup').classList.remove('show');
            document.getElementById('noteEditor').classList.remove('show');
            currentHighlightId = null;
        }

        // Copy highlight text to clipboard
        function copyHighlightText() {
            const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
            if (!highlight) return;

            navigator.clipboard.writeText(highlight.text).then(() => {
                alert('Copied to clipboard!');
                hideHighlightPopup();
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Toggle note editor
        function toggleNoteEditor() {
            const editor = document.getElementById('noteEditor');
            const input = document.getElementById('noteInput');

            if (editor.classList.contains('show')) {
                editor.classList.remove('show');
            } else {
                // Load existing note
                const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                input.value = highlight?.note || '';
                editor.classList.add('show');
                input.focus();
            }
        }

        // Save note
        async function saveNote() {
            const note = document.getElementById('noteInput').value.trim();

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({note: note})
                });

                const result = await response.json();

                if (result.success) {
                    // Update local cache
                    const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                    if (highlight) {
                        highlight.note = note;
                    }

                    // Update DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        mark.dataset.note = note;
                    }

                    alert('Note saved!');
                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                alert('Failed to save note. Please try again.');
            }
        }

        // Remove highlight
        async function removeHighlight() {
            if (!confirm('Remove this highlight?')) return;

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        const parent = mark.parentNode;
                        while (mark.firstChild) {
                            parent.insertBefore(mark.firstChild, mark);
                        }
                        parent.removeChild(mark);
                    }

                    // Remove from cache
                    loadedHighlights = loadedHighlights.filter(h => h.id !== currentHighlightId);

                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to remove highlight:', error);
                alert('Failed to remove highlight. Please try again.');
            }
        }

        // Click outside to hide popups
        // Hide popups/toolbars when clicking/touching outside
        function handleOutsideInteraction(e) {
            if (!e.target.closest('.highlight-popup') && !e.target.closest('.highlight')) {
                hideHighlightPopup();
            }
            if (!e.target.closest('.highlight-toolbar') && !e.target.closest('#chapterContent')) {
                hideHighlightToolbar();
            }

            // Close sidebar on mobile when clicking backdrop
            const isMobile = window.innerWidth <= 768;
            if (isMobile && document.body.classList.contains('sidebar-open')) {
                // Check if click is outside sidebar
                if (!e.target.closest('#sidebar') && !e.target.closest('.sidebar-toggle')) {
                    document.body.classList.remove('sidebar-open');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                }
            }
        }

        document.addEventListener('click', handleOutsideInteraction);
        document.addEventListener('touchend', handleOutsideInteraction);

        // Load highlights when page is ready
        window.addEventListener('load', loadHighlights);
    </script>
</body>
</html>
