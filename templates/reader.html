<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>

    <!-- Reader Mode Detection Meta Tags -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="{{ book.metadata.title }}">
    {% if book.metadata.creator %}
    <meta name="author" content="{{ book.metadata.creator }}">
    <meta property="article:author" content="{{ book.metadata.creator }}">
    {% endif %}
    <meta name="description" content="Reading {{ book.metadata.title }}">

    <!-- Schema.org markup for Reader Mode -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "{{ book.metadata.title }}",
      {% if book.metadata.creator %}"author": {
        "@type": "Person",
        "name": "{{ book.metadata.creator }}"
      },{% endif %}
      "inLanguage": "en"
    }
    </script>
    <style>
        /* Theme Variables */
        :root {
            --bg-main: #ffffff;
            --bg-sidebar: #fafafa;
            --bg-button: #f4f4f5;
            --bg-button-hover: #e4e4e7;
            --text-primary: #18181b;
            --text-secondary: #52525b;
            --text-muted: #a1a1aa;
            --border-subtle: #e4e4e7;
            --border-medium: #d4d4d8;
            --accent-primary: #2563eb;
            --accent-hover: #1d4ed8;
            --accent-success: #16a34a;
            --accent-active: #dc2626;
            --heading-color: #18181b;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1);
            --radius-sm: 6px;
            --radius-md: 8px;
            --transition: 0.2s ease;
        }

        body.dark-mode {
            --bg-main: #0a0a0a;
            --bg-sidebar: #141414;
            --bg-button: #262626;
            --bg-button-hover: #333333;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border-subtle: #27272a;
            --border-medium: #3f3f46;
            --accent-primary: #60a5fa;
            --accent-hover: #93c5fd;
            --accent-success: #22c55e;
            --accent-active: #f87171;
            --heading-color: #fafafa;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.3);
        }

        /* Reset & Base */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-family: "Georgia", "Times New Roman", serif;
            background: var(--bg-main);
            color: var(--text-primary);
            transition: background-color var(--transition), color var(--transition);
        }

        /* Sidebar */
        #sidebar {
            width: 280px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border-subtle);
            overflow-y: auto;
            padding: 24px 20px;
            padding-top: 56px;
            flex-shrink: 0;
            transition: transform 0.3s ease, width 0.3s ease, padding 0.3s ease, background-color var(--transition), border-color var(--transition);
            position: relative;
            z-index: 10;
        }

        body.sidebar-collapsed #sidebar {
            transform: translateX(-100%);
            width: 0;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }

        .nav-home {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 24px;
            padding-left: 36px;
            color: var(--accent-primary);
            text-decoration: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            transition: color var(--transition);
        }
        .nav-home:hover { color: var(--accent-hover); }

        .nav-title {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 0.9375rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-subtle);
            line-height: 1.4;
        }

        /* TOC */
        ul.toc-list { list-style: none; }
        ul.toc-list ul { padding-left: 16px; }
        li.toc-item { margin-bottom: 4px; }

        a.toc-link {
            display: block;
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            text-decoration: none;
            color: var(--text-secondary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 0.875rem;
            line-height: 1.4;
            transition: all var(--transition);
        }
        a.toc-link:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        a.toc-link.active {
            background: var(--accent-primary);
            color: white;
            font-weight: 500;
        }

        /* Main Content */
        #main {
            flex: 1;
            overflow-y: auto;
            position: relative;
            scroll-behavior: smooth;
            background: var(--bg-main);
            transition: background-color var(--transition);
        }

        .content-container {
            max-width: 680px;
            margin: 0 auto;
            padding: 80px 48px 60px;
            position: relative;
            transition: max-width 0.3s ease;
        }

        body.sidebar-collapsed .content-container { max-width: 760px; }

        /* Book Content */
        .book-content {
            font-size: 1.125rem;
            line-height: 1.85;
            color: var(--text-primary);
        }

        .book-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 32px auto;
            border-radius: var(--radius-sm);
        }

        .book-content h1, .book-content h2, .book-content h3 {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: var(--heading-color);
            margin-top: 2em;
            margin-bottom: 0.75em;
            line-height: 1.3;
            font-weight: 600;
        }
        .book-content h1 { font-size: 1.75rem; }
        .book-content h2 { font-size: 1.375rem; }
        .book-content h3 { font-size: 1.125rem; }

        .book-content p {
            margin-bottom: 1.5em;
            text-align: justify;
            hyphens: auto;
        }

        .book-content blockquote {
            border-left: 3px solid var(--accent-primary);
            padding-left: 1.25em;
            margin: 1.5em 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Top Action Buttons */
        .top-actions {
            position: absolute;
            top: 24px;
            right: 24px;
            display: flex;
            gap: 6px;
            align-items: center;
            z-index: 15;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: var(--bg-button);
            color: var(--text-secondary);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition);
            text-decoration: none;
        }
        .action-btn:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .action-btn.copied {
            background: var(--accent-success);
            color: white;
        }

        .action-btn svg { width: 16px; height: 16px; }

        /* Sidebar Toggle */
        .sidebar-toggle {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 36px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-button);
            color: var(--text-secondary);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            z-index: 20;
            transition: all var(--transition);
        }
        .sidebar-toggle:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            #sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 280px;
                z-index: 30;
                transform: translateX(-100%);
                box-shadow: var(--shadow-md);
            }

            body.sidebar-open #sidebar {
                transform: translateX(0);
            }

            #main { width: 100%; }

            .content-container {
                max-width: 100%;
                padding: 72px 20px 40px;
            }

            .sidebar-toggle {
                left: 12px;
                top: 12px;
            }

            .sidebar-toggle.hidden {
                opacity: 0;
                pointer-events: none;
            }

            body.sidebar-open::before {
                content: '';
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 25;
            }

            .top-actions {
                top: 12px;
                right: 12px;
            }
        }

        /* Chapter Navigation */
        .chapter-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 64px;
            padding-top: 24px;
            border-top: 1px solid var(--border-subtle);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .nav-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 20px;
            background: transparent;
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            text-decoration: none;
            transition: all var(--transition);
        }
        .nav-btn:hover {
            background: var(--accent-primary);
            color: white;
        }
        .nav-btn.disabled {
            opacity: 0.4;
            pointer-events: none;
            border-color: var(--border-medium);
            color: var(--text-muted);
        }

        .chapter-info {
            font-size: 0.8125rem;
            color: var(--text-muted);
        }

        /* Highlights */
        mark.highlight {
            background-color: #fef08a;
            cursor: pointer;
            padding: 1px 2px;
            border-radius: 2px;
            transition: background-color var(--transition);
        }
        mark.highlight:hover {
            background-color: #fde047;
        }
        body.dark-mode mark.highlight {
            background-color: #854d0e;
            color: #fef9c3;
        }
        body.dark-mode mark.highlight:hover {
            background-color: #a16207;
        }

        /* Highlight Toolbar */
        .highlight-toolbar {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 6px 10px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            display: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .highlight-toolbar.show { display: block; }

        .highlight-toolbar button {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: background var(--transition);
        }
        .highlight-toolbar button:hover {
            background: var(--accent-hover);
        }

        /* Highlight Popup */
        .highlight-popup {
            position: absolute;
            background: var(--bg-button);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: 4px;
            z-index: 1000;
            display: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .highlight-popup.show {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .highlight-popup button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: transparent;
            color: var(--text-primary);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.8125rem;
            cursor: pointer;
            text-align: left;
            white-space: nowrap;
            transition: background var(--transition);
        }
        .highlight-popup button:hover {
            background: var(--bg-button-hover);
        }

        .highlight-popup .divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 4px 0;
        }

        /* Note Editor */
        .note-editor {
            padding: 8px;
            display: none;
        }
        .note-editor.show { display: block; }

        .note-editor textarea {
            width: 240px;
            min-height: 64px;
            padding: 10px;
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-sm);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 0.875rem;
            background: var(--bg-main);
            color: var(--text-primary);
            resize: vertical;
            transition: border-color var(--transition);
        }
        .note-editor textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .note-editor button {
            margin-top: 8px;
            padding: 6px 14px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: background var(--transition);
        }
        .note-editor button:hover {
            background: var(--accent-hover);
        }
    </style>
</head>
<body>
    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="Toggle sidebar">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" id="sidebarIcon">
            <!-- Hamburger icon (default - sidebar open) -->
            <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
        </svg>
    </button>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="{{ root_path }}/" class="nav-home">‚Üê Library</a>
        <div class="nav-title">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <main id="main">
        <div class="content-container">
            <!-- Top Action Buttons -->
            <div class="top-actions">
                <button class="action-btn" id="copyBtn" onclick="copyChapter()" title="Copy to clipboard">
                    <svg viewBox="0 0 16 16" fill="currentColor">
                        <path d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Z"></path>
                        <path d="M2 6a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-1h-1v1a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h1V6H2Z"></path>
                    </svg>
                </button>
                <a href="{{ root_path }}/highlights" class="action-btn" title="Highlights">
                    <svg viewBox="0 0 16 16" fill="currentColor">
                        <path d="M5.5 7a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5zM5 9.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5z"/>
                        <path d="M9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.5L9.5 0zm0 1v2A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5z"/>
                    </svg>
                </a>
                <button class="action-btn" id="themeToggle" onclick="toggleDarkMode()" title="Toggle theme">
                    <svg viewBox="0 0 16 16" fill="currentColor" id="themeIcon">
                        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>
                    </svg>
                </button>
            </div>
            <article class="book-content" id="chapterContent">
                {{ current_chapter.content | safe }}
            </article>

            <nav class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span class="chapter-info">{{ chapter_index + 1 }} / {{ book.spine|length }}</span>

                {% if next_idx is not none %}
                    <a href="{{ root_path }}/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </nav>

            <!-- Floating Highlight Toolbar -->
            <div class="highlight-toolbar" id="highlightToolbar">
                <button onclick="createHighlight()">‚ú® Highlight</button>
            </div>

            <!-- Highlight Popup Menu -->
            <div class="highlight-popup" id="highlightPopup">
                <button onclick="copyHighlightText()">
                    <span>üìã</span> Copy
                </button>
                <button onclick="toggleNoteEditor()">
                    <span>üìù</span> <span id="noteButtonLabel">Add Note</span>
                </button>
                <div class="divider"></div>
                <button onclick="removeHighlight()" style="color: #dc3545;">
                    <span>üóëÔ∏è</span> Remove
                </button>
                <div class="note-editor" id="noteEditor">
                    <textarea id="noteInput" placeholder="Add your note here..."></textarea>
                    <button onclick="saveNote()">Save Note</button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Highlight state
        let currentSelection = null;
        let currentHighlightId = null;
        let loadedHighlights = [];
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "{{ root_path }}/read/{{ book_id }}/" + idx;
                // If there's an anchor, preserve it in the URL hash
                if (anchor) {
                    url += "#" + anchor;
                }

                // Auto-close sidebar after clicking TOC link
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    // On mobile, close the sidebar
                    document.body.classList.remove('sidebar-open');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                } else {
                    // On desktop, collapse the sidebar
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                }

                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        function scrollToAnchor() {
            // Check if there's a hash in the URL
            const hash = window.location.hash;
            if (hash) {
                // Remove the # to get the element ID
                const elementId = hash.substring(1);
                const targetElement = document.getElementById(elementId);

                if (targetElement) {
                    // Scroll within the #main container, not the window
                    setTimeout(() => {
                        const mainContainer = document.getElementById('main');
                        const containerRect = mainContainer.getBoundingClientRect();
                        const targetRect = targetElement.getBoundingClientRect();

                        // Calculate the scroll position: current scroll + target position relative to container
                        const scrollTo = mainContainer.scrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                        // Smooth scroll within the container
                        mainContainer.scrollTo({
                            top: scrollTo,
                            behavior: 'smooth'
                        });

                        // Add a temporary highlight to show where we scrolled
                        targetElement.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                        setTimeout(() => {
                            targetElement.style.backgroundColor = '';
                        }, 2000);
                    }, 100);
                } else {
                    console.log("Anchor element not found:", elementId);
                }
            }
        }

        function scrollSidebarToActive() {
            // Find the currently active TOC link
            const activeLink = document.querySelector('.toc-link.active');
            if (!activeLink) {
                console.log('scrollSidebarToActive: No active link found');
                return;
            }

            const sidebar = document.querySelector('#sidebar');
            if (!sidebar) {
                console.log('scrollSidebarToActive: No sidebar found');
                return;
            }

            console.log('scrollSidebarToActive: Scrolling to active item:', activeLink.textContent.trim().substring(0, 50));

            // Get positions
            const sidebarRect = sidebar.getBoundingClientRect();
            const linkRect = activeLink.getBoundingClientRect();

            // Calculate scroll position: current scroll + link position relative to sidebar - offset to center
            const scrollTo = sidebar.scrollTop + (linkRect.top - sidebarRect.top) - (sidebarRect.height / 3);

            console.log('scrollSidebarToActive: Current scroll:', sidebar.scrollTop, 'Target scroll:', Math.max(0, scrollTo));

            // Smooth scroll the sidebar
            sidebar.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
            });
        }

        function updateActiveTOCItem() {
            console.log('=== updateActiveTOCItem called ===');

            // Get current chapter index and hash from the URL
            const pathParts = window.location.pathname.split('/');
            const currentChapterIndex = parseInt(pathParts[pathParts.length - 1]);
            const currentHash = window.location.hash.substring(1); // Remove the #

            console.log('Current pathname:', window.location.pathname);
            console.log('Chapter index:', currentChapterIndex);
            console.log('Current hash:', currentHash);

            // Find the current chapter's href from spine
            const spineEntries = Object.entries(spineMap);
            const currentChapterFile = spineEntries.find(([file, idx]) => idx === currentChapterIndex)?.[0];

            console.log('Current chapter file:', currentChapterFile);

            if (!currentChapterFile) {
                console.log('ERROR: No chapter file found for index', currentChapterIndex);
                return;
            }

            // Build the full href we're looking for
            const targetHref = currentHash ? `${currentChapterFile}#${currentHash}` : currentChapterFile;
            console.log('Target href to match:', targetHref);

            // Remove active class from all TOC links
            document.querySelectorAll('.toc-link').forEach(link => {
                link.classList.remove('active');
            });

            // Find and activate the matching TOC link
            let matchFound = false;
            document.querySelectorAll('.toc-link').forEach(link => {
                const onclick = link.getAttribute('onclick');
                if (onclick) {
                    // Extract the href from onclick="findAndGo('...')"
                    const match = onclick.match(/findAndGo\('([^']+)'\)/);
                    if (match) {
                        const linkHref = match[1];
                        if (linkHref === targetHref) {
                            console.log('MATCH FOUND:', linkHref, link.textContent.trim().substring(0, 50));
                            link.classList.add('active');
                            matchFound = true;
                        }
                    }
                }
            });

            if (!matchFound) {
                console.log('WARNING: No matching TOC link found for', targetHref);
            }

            // Scroll sidebar to show the active item (with small delay to ensure DOM has updated)
            setTimeout(() => {
                scrollSidebarToActive();
            }, 100);
        }

        // Call scrollToAnchor when the page loads
        window.addEventListener('load', () => {
            scrollToAnchor();
            updateActiveTOCItem();
        });

        // Also call scrollToAnchor when navigating within the same page (hash changes)
        window.addEventListener('hashchange', () => {
            console.log('üîÑ hashchange event fired! New hash:', window.location.hash);
            scrollToAnchor();
            updateActiveTOCItem();
        });

        function copyChapter() {
            const content = document.getElementById('chapterContent');
            const text = content.innerText || content.textContent;

            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></svg>';
                btn.classList.add('copied');

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Dark Mode Functions
        function updateThemeIcon(isDark) {
            const icon = document.getElementById('themeIcon');
            if (isDark) {
                // Sun icon for dark mode (click to go light)
                icon.innerHTML = '<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path>';
            } else {
                // Moon icon for light mode (click to go dark)
                icon.innerHTML = '<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>';
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const isDark = body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcon(isDark);
        }

        function initTheme() {
            // Check localStorage first, then system preference
            let theme = localStorage.getItem('theme');
            if (!theme) {
                // Check system preference
                theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }

            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                updateThemeIcon(true);
            }
        }

        // Initialize theme on page load (before body renders to avoid flash)
        initTheme();

        // Sidebar Toggle Functions
        function updateSidebarIcon(isCollapsed) {
            const icon = document.getElementById('sidebarIcon');
            if (isCollapsed) {
                // Hamburger icon (sidebar closed - click to open)
                icon.innerHTML = '<path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>';
            } else {
                // Left arrow/chevron icon (sidebar open - click to close)
                icon.innerHTML = '<path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"></path>';
            }
        }

        function toggleSidebar() {
            const body = document.body;
            const isMobile = window.innerWidth <= 768;

            if (isMobile) {
                // On mobile, toggle sidebar-open class
                const isOpen = body.classList.toggle('sidebar-open');
                localStorage.setItem('sidebar', isOpen ? 'open' : 'closed');
                updateSidebarIcon(!isOpen); // Icon shows opposite state
            } else {
                // On desktop, toggle sidebar-collapsed class
                const isCollapsed = body.classList.toggle('sidebar-collapsed');
                localStorage.setItem('sidebar', isCollapsed ? 'closed' : 'open');
                updateSidebarIcon(isCollapsed);
            }
        }

        function initSidebar() {
            // Check localStorage and screen size
            let sidebarState = localStorage.getItem('sidebar');
            const isMobile = window.innerWidth <= 768;

            // Auto-collapse on mobile if no saved preference
            if (!sidebarState && isMobile) {
                sidebarState = 'closed';
            }

            if (isMobile) {
                // On mobile, use sidebar-open class
                if (sidebarState === 'open') {
                    document.body.classList.add('sidebar-open');
                    updateSidebarIcon(false);
                } else {
                    // Default: sidebar hidden on mobile (no sidebar-open class)
                    updateSidebarIcon(true);
                }
            } else {
                // On desktop, use sidebar-collapsed class
                if (sidebarState === 'closed') {
                    document.body.classList.add('sidebar-collapsed');
                    updateSidebarIcon(true);
                } else {
                    updateSidebarIcon(false);
                }
            }
        }

        // Initialize sidebar on page load
        initSidebar();

        // Auto-hide sidebar toggle button on mobile after inactivity
        if (window.innerWidth <= 768) {
            let hideTimeout;
            const sidebarToggle = document.getElementById('sidebarToggle');

            function resetHideTimer() {
                sidebarToggle.classList.remove('hidden');
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (!document.body.classList.contains('sidebar-open')) {
                        sidebarToggle.classList.add('hidden');
                    }
                }, 1000);
            }

            document.addEventListener('touchstart', resetHideTimer);
            document.addEventListener('touchmove', resetHideTimer);
            document.addEventListener('scroll', resetHideTimer, true);

            // Initial timer
            resetHideTimer();
        }

        // Keyboard shortcut: Cmd/Ctrl + Shift + P to toggle sidebar
        document.addEventListener('keydown', function(e) {
            // Check for Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux)
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'P' || e.key === 'p')) {
                e.preventDefault();
                toggleSidebar();
            }
        });

        // ===== HIGHLIGHTING SYSTEM =====

        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const chapterHref = "{{ current_chapter.href }}";

        // Load highlights for current chapter on page load
        async function loadHighlights() {
            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`);
                const data = await response.json();
                loadedHighlights = data.highlights.filter(h => h.chapter_index === chapterIndex);

                // Apply highlights to content
                loadedHighlights.forEach(highlight => {
                    applyHighlightToDOM(highlight);
                });

                // After highlights are applied, check if we need to scroll to a specific highlight
                scrollToHighlightFromHash();
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }

        // Scroll to a highlight if the URL hash contains a highlight ID
        function scrollToHighlightFromHash() {
            const hash = window.location.hash;
            if (!hash || !hash.startsWith('#highlight-')) return;

            const highlightId = hash.substring('#highlight-'.length);
            const highlightMark = document.querySelector(`mark[data-highlight-id="${highlightId}"]`);

            if (highlightMark) {
                scrollToElementAndHighlight(highlightMark);
            } else {
                // Fallback: try to scroll to the approximate position using offset
                const highlight = loadedHighlights.find(h => h.id === highlightId);
                if (highlight && highlight.start_offset) {
                    scrollToOffset(highlight.start_offset, highlight.text);
                } else {
                    console.log('Highlight not found:', highlightId);
                }
            }
        }

        // Helper function to scroll to an element and highlight it
        function scrollToElementAndHighlight(element) {
            const mainContainer = document.getElementById('main');
            const containerRect = mainContainer.getBoundingClientRect();
            const targetRect = element.getBoundingClientRect();

            // Calculate scroll position to center the highlight in view
            const scrollTo = mainContainer.scrollTop + (targetRect.top - containerRect.top) - (containerRect.height / 3);

            // Smooth scroll to the highlight
            mainContainer.scrollTo({
                top: Math.max(0, scrollTo),
                behavior: 'smooth'
            });

            // Add a temporary visual emphasis to show which highlight we scrolled to
            const originalBackground = element.style.backgroundColor;
            element.style.backgroundColor = '#ff6b6b';
            element.style.transition = 'background-color 0.3s';
            setTimeout(() => {
                element.style.backgroundColor = originalBackground || '';
                setTimeout(() => {
                    element.style.transition = '';
                }, 300);
            }, 2000);
        }

        // Scroll to a position in the content based on text offset
        function scrollToOffset(targetOffset, searchText) {
            const content = document.getElementById('chapterContent');
            const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null);

            let currentOffset = 0;
            let node;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeEndOffset = currentOffset + nodeLength;

                // Check if target offset falls within this node or text is found
                if (targetOffset < nodeEndOffset || node.textContent.includes(searchText)) {
                    // Found the approximate location - scroll to this node's parent element
                    let targetElement = node.parentElement;

                    // Try to find a better parent (paragraph, div, etc.)
                    while (targetElement && !['P', 'DIV', 'SECTION', 'ARTICLE', 'LI', 'BLOCKQUOTE'].includes(targetElement.tagName)) {
                        if (targetElement.parentElement && targetElement.parentElement.id !== 'chapterContent') {
                            targetElement = targetElement.parentElement;
                        } else {
                            break;
                        }
                    }

                    if (targetElement) {
                        scrollToElementAndHighlight(targetElement);
                    }
                    return;
                }

                currentOffset += nodeLength;
            }
        }

        // Apply a highlight to the DOM by wrapping text in <mark>
        function applyHighlightToDOM(highlight) {
            const content = document.getElementById('chapterContent');
            const fullText = content.textContent;
            const targetOffset = highlight.start_offset || 0;
            const highlightText = highlight.text;

            // Find the text at the specified offset
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let currentOffset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                const nodeStartOffset = currentOffset;
                const nodeEndOffset = currentOffset + nodeLength;

                // Check if our target offset falls within this node
                if (targetOffset >= nodeStartOffset && targetOffset < nodeEndOffset) {
                    const localOffset = targetOffset - nodeStartOffset;
                    const textInNode = node.textContent.substring(localOffset);

                    // Verify the text matches
                    if (textInNode.startsWith(highlightText)) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localOffset);

                            // Calculate end position (might span multiple nodes)
                            const endOffset = Math.min(localOffset + highlightText.length, nodeLength);
                            range.setEnd(node, endOffset);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight';
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            found = true;
                            break;
                        } catch (e) {
                            console.warn('Could not apply highlight at offset', targetOffset, e);
                        }
                    }
                }

                currentOffset += nodeLength;
            }

            // Fallback: if offset-based matching failed, try simple text search
            if (!found) {
                currentOffset = 0;
                const walker2 = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, null);
                while (node = walker2.nextNode()) {
                    const text = node.textContent;
                    const localIndex = text.indexOf(highlightText);

                    if (localIndex !== -1) {
                        try {
                            const range = document.createRange();
                            range.setStart(node, localIndex);
                            range.setEnd(node, localIndex + highlightText.length);

                            const mark = document.createElement('mark');
                            mark.className = 'highlight';
                            mark.dataset.highlightId = highlight.id;
                            mark.dataset.note = highlight.note || '';

                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, highlight.id));
                            found = true;
                            break;
                        } catch (e) {
                            console.warn('Fallback highlight failed:', e);
                        }
                    }
                    currentOffset += text.length;
                }
            }

            return found;
        }

        // Text selection detection
        // Listen for both mouse and touch events for text selection
        const chapterContent = document.getElementById('chapterContent');
        chapterContent.addEventListener('mouseup', handleTextSelection);

        // On mobile, use selectionchange with debouncing
        let selectionTimeout;
        document.addEventListener('selectionchange', () => {
            clearTimeout(selectionTimeout);
            selectionTimeout = setTimeout(() => {
                const selection = window.getSelection();
                if (selection.toString().trim().length > 0) {
                    // Check if the selection is within our chapter content
                    const range = selection.getRangeAt(0);
                    if (chapterContent.contains(range.commonAncestorContainer)) {
                        handleTextSelection();
                    }
                }
            }, 300); // Wait 300ms after selection changes stop
        });

        function handleTextSelection(e) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 0) {
                currentSelection = {
                    text: selectedText,
                    range: selection.getRangeAt(0).cloneRange()
                };

                // Show highlight button near selection
                const rect = selection.getRangeAt(0).getBoundingClientRect();
                const toolbar = document.getElementById('highlightToolbar');
                const containerRect = document.querySelector('.content-container').getBoundingClientRect();

                // Position relative to the content-container
                // Both rect and containerRect are viewport-relative, so their difference
                // gives us the position within the container (which is the toolbar's offsetParent)
                toolbar.style.top = `${rect.bottom - containerRect.top + 5}px`;
                toolbar.style.left = `${rect.left - containerRect.left}px`;
                toolbar.classList.add('show');
            } else {
                hideHighlightToolbar();
            }
        }

        function hideHighlightToolbar() {
            document.getElementById('highlightToolbar').classList.remove('show');
        }

        // Calculate offset of a range in the content
        function calculateOffset(range) {
            const content = document.getElementById('chapterContent');
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null
            );

            let offset = 0;
            let node;
            let found = false;

            while (node = walker.nextNode()) {
                if (node === range.startContainer) {
                    offset += range.startOffset;
                    found = true;
                    break;
                }
                offset += node.textContent.length;
            }

            return found ? offset : 0;
        }

        // Create a new highlight
        async function createHighlight() {
            if (!currentSelection) return;

            // Calculate the actual offset in the content
            const startOffset = calculateOffset(currentSelection.range);

            const highlightData = {
                text: currentSelection.text,
                chapter_index: chapterIndex,
                chapter_href: chapterHref,
                start_offset: startOffset,
                end_offset: startOffset + currentSelection.text.length,
                color: "yellow"
            };

            try {
                const response = await fetch(`{{ root_path }}/api/books/${bookId}/highlights`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(highlightData)
                });

                const result = await response.json();

                if (result.success) {
                    // Apply highlight to DOM using more robust method
                    try {
                        const range = currentSelection.range;
                        const mark = document.createElement('mark');
                        mark.className = 'highlight';
                        mark.dataset.highlightId = result.highlight.id;
                        mark.dataset.note = '';

                        // Try simple surroundContents first (works for single-element selections)
                        try {
                            range.surroundContents(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, result.highlight.id));
                        } catch (e) {
                            // If that fails (selection crosses elements), use extractContents + appendChild
                            const fragment = range.extractContents();
                            mark.appendChild(fragment);
                            range.insertNode(mark);
                            mark.addEventListener('click', (e) => showHighlightPopup(e, result.highlight.id));
                        }

                        // Add to loaded highlights
                        loadedHighlights.push(result.highlight);
                    } catch (e) {
                        console.error('Failed to apply highlight:', e);
                        alert('Failed to apply highlight. Please try selecting within a single paragraph.');
                    }

                    // Clear selection
                    window.getSelection().removeAllRanges();
                    hideHighlightToolbar();
                }
            } catch (error) {
                console.error('Failed to create highlight:', error);
                alert('Failed to create highlight. Please try again.');
            }
        }

        // Show popup menu for existing highlight
        function showHighlightPopup(e, highlightId) {
            e.stopPropagation();

            currentHighlightId = highlightId;

            const highlight = loadedHighlights.find(h => h.id === highlightId);
            if (!highlight) return;

            // Update note button label
            const noteLabel = document.getElementById('noteButtonLabel');
            noteLabel.textContent = highlight.note ? 'Edit Note' : 'Add Note';

            // Position popup
            const popup = document.getElementById('highlightPopup');
            const rect = e.target.getBoundingClientRect();
            const containerRect = document.querySelector('.content-container').getBoundingClientRect();

            // Position relative to the content-container
            // Both rect and containerRect are viewport-relative, so their difference
            // gives us the position within the container (which is the popup's offsetParent)
            popup.style.top = `${rect.bottom - containerRect.top + 5}px`;
            popup.style.left = `${rect.left - containerRect.left}px`;
            popup.classList.add('show');

            // Hide note editor initially
            document.getElementById('noteEditor').classList.remove('show');
        }

        function hideHighlightPopup() {
            document.getElementById('highlightPopup').classList.remove('show');
            document.getElementById('noteEditor').classList.remove('show');
            currentHighlightId = null;
        }

        // Copy highlight text to clipboard
        function copyHighlightText() {
            const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
            if (!highlight) return;

            navigator.clipboard.writeText(highlight.text).then(() => {
                alert('Copied to clipboard!');
                hideHighlightPopup();
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Toggle note editor
        function toggleNoteEditor() {
            const editor = document.getElementById('noteEditor');
            const input = document.getElementById('noteInput');

            if (editor.classList.contains('show')) {
                editor.classList.remove('show');
            } else {
                // Load existing note
                const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                input.value = highlight?.note || '';
                editor.classList.add('show');
                input.focus();
            }
        }

        // Save note
        async function saveNote() {
            const note = document.getElementById('noteInput').value.trim();

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({note: note})
                });

                const result = await response.json();

                if (result.success) {
                    // Update local cache
                    const highlight = loadedHighlights.find(h => h.id === currentHighlightId);
                    if (highlight) {
                        highlight.note = note;
                    }

                    // Update DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        mark.dataset.note = note;
                    }

                    alert('Note saved!');
                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                alert('Failed to save note. Please try again.');
            }
        }

        // Remove highlight
        async function removeHighlight() {
            if (!confirm('Remove this highlight?')) return;

            try {
                const response = await fetch(`{{ root_path }}/api/highlights/${currentHighlightId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from DOM
                    const mark = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                    if (mark) {
                        const parent = mark.parentNode;
                        while (mark.firstChild) {
                            parent.insertBefore(mark.firstChild, mark);
                        }
                        parent.removeChild(mark);
                    }

                    // Remove from cache
                    loadedHighlights = loadedHighlights.filter(h => h.id !== currentHighlightId);

                    hideHighlightPopup();
                }
            } catch (error) {
                console.error('Failed to remove highlight:', error);
                alert('Failed to remove highlight. Please try again.');
            }
        }

        // Click outside to hide popups
        // Hide popups/toolbars when clicking/touching outside
        function handleOutsideInteraction(e) {
            if (!e.target.closest('.highlight-popup') && !e.target.closest('.highlight')) {
                hideHighlightPopup();
            }
            if (!e.target.closest('.highlight-toolbar') && !e.target.closest('#chapterContent')) {
                hideHighlightToolbar();
            }

            // Close sidebar on mobile when clicking backdrop
            const isMobile = window.innerWidth <= 768;
            if (isMobile && document.body.classList.contains('sidebar-open')) {
                // Check if click is outside sidebar
                if (!e.target.closest('#sidebar') && !e.target.closest('.sidebar-toggle')) {
                    document.body.classList.remove('sidebar-open');
                    updateSidebarIcon(true);
                    localStorage.setItem('sidebar', 'closed');
                }
            }
        }

        document.addEventListener('click', handleOutsideInteraction);
        document.addEventListener('touchend', handleOutsideInteraction);

        // Load highlights when page is ready
        window.addEventListener('load', loadHighlights);

        // ===== READING PROGRESS TRACKING =====
        const totalChapters = {{ book.spine|length }};

        function saveProgress() {
            const mainContainer = document.getElementById('main');
            const scrollPercent = mainContainer.scrollTop / (mainContainer.scrollHeight - mainContainer.clientHeight);
            const clampedScroll = Math.min(1, Math.max(0, scrollPercent || 0));

            fetch(`{{ root_path }}/api/books/${bookId}/progress`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chapter_index: chapterIndex,
                    scroll_percent: clampedScroll,
                    total_chapters: totalChapters
                })
            }).catch(err => console.error('Failed to save progress:', err));
        }

        // Debounce scroll saves
        let progressTimeout = null;
        document.getElementById('main').addEventListener('scroll', () => {
            if (progressTimeout) clearTimeout(progressTimeout);
            progressTimeout = setTimeout(saveProgress, 1000);
        });

        // Save progress on page unload
        window.addEventListener('beforeunload', saveProgress);

        // Save progress on chapter load
        window.addEventListener('load', () => {
            setTimeout(saveProgress, 500);
        });
    </script>
</body>
</html>
